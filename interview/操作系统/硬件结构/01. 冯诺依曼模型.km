{
    "root": {
        "data": {
            "id": "cva3b5me3oo0",
            "created": 1693826294889,
            "text": "冯诺依曼模型",
            "note": "冯诺依曼模型: **运算器、控制器、存储器、输入设备、输出设备**。\n\n运算器、控制器是在中央处理器里的，存储器就我们常见的内存，输入输出设备则是计算机外接的设备，比如键盘就是输入设备，显示器就是输出设备。\n\n存储单元和输入输出设备要与中央处理器打交道的话，离不开总线。\n\n![](https://camo.githubusercontent.com/2955857563b270d7aa23a880920783e247470b1c83221c424f9131d229e50035/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545372541382538422545352542412538462545362538392541372545382541312538432f2545352538362541462545382541462542412545342542452539442545362539422542432545362541382541312545352539452538422e706e67)"
        },
        "children": [
            {
                "data": {
                    "id": "cva3dwmgs1k0",
                    "created": 1693826510395,
                    "text": "内存",
                    "note": "我们的程序和数据都是存储在内存，存储的区域是**线性的**。\n\n在计算机数据存储中，存储数据的基本单位是字节（byte），1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。\n\n内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cva3ej7fsb40",
                    "created": 1693826559552,
                    "text": "中央处理器",
                    "note": "32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：\n\n- 32 位 CPU 一次可以计算 4 个字节；\n- 64 位 CPU 一次可以计算 8 个字节；\n\n这里的 32 位和 64 位，通常称为 CPU 的**位宽**。\n\nCPU 内部还有一些组件，常见的有**寄存器、控制单元和逻辑运算单元**等。其中：\n\n- 控制单元负责控制 CPU 工作；\n- 逻辑运算单元负责计算；\n- 而寄存器可以分为多种类，每种寄存器的功能又不尽相同，主要作用是存储计算时的数据。因为内存离 CPU 太远了，而寄存器就在 CPU 里，还紧挨着控制单元和逻辑运算单元，自然计算时速度会很快。\n\n常见的寄存器种类：\n\n- 通用寄存器，用来存放需要进行运算的数据，比如需要进行和运算的两个数据。\n- 程序计数器，用来存储 CPU 要执行下一条指令**所在的内存地址**，注意不是存储了下一条要执行的指令，此时指令还在内存中。\n- 指令寄存器，用来存放当前正在执行的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。\n"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cva3ijkzha80",
                    "created": 1693826873828,
                    "text": "总线",
                    "note": "用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：\n\n- 地址总线，用于指定 CPU 将要操作的内存地址；\n- 控制总线，用于读写内存的数据；\n- 数据总线，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；\n\nCPU 读写内存数据的过程：\n\n1. 首先通过地址总线指定内存的地址\n1. 然后通过控制总线控制是 读或写 命令\n1. 最后通过数据总线传输数据"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cva3lqq63eg0",
                    "created": 1693827124471,
                    "text": "输入、输出设备",
                    "note": "输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。\n"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cva3nbsiws80",
                    "created": 1693827248690,
                    "text": "线路位宽与 CPU 位宽",
                    "note": null
                },
                "children": [
                    {
                        "data": {
                            "id": "cva3qymg1vs0",
                            "created": 1693827533481,
                            "text": "线路位宽",
                            "note": "数据是通过操作电压进行通过线路传输的，低电压表示 0，高压电压则表示 1。\n\n如果只有一条线路，就意味着每次只能传递 1 bit 的数据，即 0 或 1。这样一位一位传输的方式，称为**串行**，下一个 bit 必须等待上一个 bit 传输完成才能进行传输。当然，想一次多传一些数据，增加线路即可，这时数据就可以并行传输。\n\n为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。\n\nCPU 想要操作「内存地址」就需要「地址总线」。\n\n那么，想要 CPU 操作 4G 大的内存，那么就需要 32 条地址总线，因为 `2 ^ 32 = 4G`。\n"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cva3r2i73hc0",
                            "created": 1693827541931,
                            "text": "CPU 位宽",
                            "note": "CPU 的位宽最好不要小于线路位宽，比如 32 位 CPU 控制 40 位宽的地址总线和数据总线的话，工作起来就会非常复杂且麻烦，所以 32 位的 CPU 最好和 32 位宽的线路搭配，因为 32 位 CPU 一次最多只能操作 32 位宽的地址总线和数据总线。\n\n如果用 32 位 CPU 去加和两个 64 位大小的数字，就需要把这 2 个 64 位的数字分成 2 个低位 32 位数字和 2 个高位 32 位数字来计算，先加个两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位，就能算出结果了，可以发现 32 位 CPU 并不能一次性计算出加和两个 64 位数字的结果。\n\n64 位 CPU 性能比 32 位 CPU 高很多，很少应用需要算超过 32 位的数字，所以**如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 CPU 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来**。\n\n另外，32 位 CPU 最大只能操作 4GB 内存，就算你装了 8 GB 内存条，也没用。而 64 位 CPU 寻址范围则很大，理论最大的寻址空间为 `2^64`。"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cva4u4iat0g0",
                    "created": 1693830602494,
                    "text": "为什么64位软件不能运行在32位的电脑上",
                    "note": "硬件的 64 位和 32 位指的是 CPU 的位宽，软件的 64 位和 32 位指的是指令的位宽。\n\n64 位和 32 位软件，实际上代表指令是 64 位还是 32 位的：\n\n- 如果 32 位指令在 64 位机器上执行，需要一套兼容机制，就可以做到兼容运行了。但是如果 64 位指令在 32 位机器上执行，就比较困难了，**因为 32 位的寄存器存不下 64 位的指令**；\n- 操作系统其实也是一种程序，我们也会看到操作系统会分成 32 位操作系统、64 位操作系统，其代表意义就是操作系统中程序的指令是多少位，比如 64 位操作系统，指令也就是 64 位，因此不能装在 32 位机器上。\n"
                },
                "children": []
            }
        ]
    },
    "template": "right",
    "theme": "classic",
    "version": "1.4.43"
}