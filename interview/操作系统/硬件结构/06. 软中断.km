{
    "root": {
        "data": {
            "id": "cvavf5tc4mo0",
            "created": 1693905599843,
            "text": "软中断"
        },
        "children": [
            {
                "data": {
                    "id": "cvavfc6d9080",
                    "created": 1693905613691,
                    "text": "中断",
                    "note": "在计算机中，中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。\n\n操作系统收到了中断请求，会打断其他进程的运行，所以**中断请求的响应程序，也就是中断处理程序，要尽可能快的执行完，这样可以减少对正常进程运行调度地影响**。\n\n而且，中断处理程序在响应中断时，可能还会「临时关闭中断」，这意味着，如果当前中断处理程序没有执行完之前，系统中其他的中断请求都无法被响应，也就说中断有可能会丢失，所以中断处理程序要短且快。\n"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cvavgq0pbjc0",
                    "created": 1693905722188,
                    "text": "软中断",
                    "note": " Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部分和下半部分」。\n\n- 上半部用来快速处理中断，一般会暂时关闭中断请求，主要负责处理跟**硬件**紧密相关或者**时间敏感**的事情。硬中断\n- 下半部用来延迟处理上半部未完成的工作，一般以**内核线程**的方式运行。由内核触发，软中断。\n\n硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行，并且每一个 CPU 都对应一个软中断内核线程，名字通常为`ksoftirqd/CPU 编号`，比如 0 号 CPU 对应的软中断内核线程的名字是 ksoftirqd/0。\n\n不过，软中断不只是包括硬件设备中断处理程序的下半部，一些内核自定义事件也属于软中断，比如内核调度等、RCU 锁（内核里常用的一种锁）等。"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cvavm98aogg0",
                    "created": 1693906155827,
                    "text": "查看软中断",
                    "note": "在 Linux 系统里，我们可以通过查看 `/proc/softirqs` 的 内容来知晓「软中断」的运行情况，以及 `/proc/interrupts` 的 内容来知晓「硬中断」的运行情况。\n\n![](https://camo.githubusercontent.com/b5d1775d639929b3a59e74f1980f19761202d795f15b9c3d70e468726d251e85/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545382542442541462545342542382541442545362539362541442f736f6674697271732e706e67)\n每一个 CPU 都有自己对应的不同类型软中断的**累计运行次数**。\n\n- 第一列的内容，它是代表着软中断的类型，在我的系统里，软中断包括了 10 个类型，分别对应不同的工作类型，比如 NET_RX 表示网络接收中断，NET_TX 表示网络发送中断、TIMER 表示定时中断、RCU 表示 RCU 锁中断、SCHED 表示内核调度中断。\n- 正常情况下，同一种中断在不同 CPU 上的累计次数相差不多\n- 这些数值是系统运行以来的累计中断次数，数值的大小没什么参考意义，但是系统的中断次数的**变化速率**才是我们要关注的，我们可以使用 `watch -d cat /proc/softirqs` 命令查看中断次数的变化速率。"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cvavp7ve1g00",
                    "created": 1693906387962,
                    "text": "定位软中断 CPU 使用率过高的问题",
                    "note": "要想知道当前的系统的软中断情况，我们可以使用 top 命令查看 `si` 数值，这个是百分比数值。\n\n如果要知道是哪种软中断类型导致的，我们可以使用 `watch -d cat /proc/softirqs` 命令查看每个软中断类型的中断次数的变化速率。\n\n如果发现 NET_RX 网络接收中断次数的变化速率过快，接下来就可以使用 `sar -n DEV` 查看网卡的网络包接收速率情况，然后分析是哪个网卡有大量的网络包进来。\n\n接着，在通过 tcpdump 抓包，分析这些包的来源，如果是非法的地址，可以考虑加防火墙，如果是正常流量，则要考虑硬件升级等。"
                },
                "children": []
            }
        ]
    },
    "template": "right",
    "theme": "classic",
    "version": "1.4.43"
}