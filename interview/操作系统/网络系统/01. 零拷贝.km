{
    "root": {
        "data": {
            "id": "cvspn3i7ri80",
            "created": 1695717374291,
            "text": "零拷贝",
            "note": "针对优化磁盘的技术非常的多，比如零拷贝、直接 I/O、异步 I/O 等等，这些优化的目的就是为了提高系统的吞吐量，另外操作系统内核中的磁盘高速缓存区，可以有效的减少磁盘的访问次数。\n\n"
        },
        "children": [
            {
                "data": {
                    "id": "cvspoly57pc0",
                    "created": 1695717492800,
                    "text": "DMA",
                    "note": "在没有 DMA 技术前，I/O 的过程是这样的：\n\n1. CPU发出对应的指令给磁盘控制器，然后返回\n1. 磁盘控制器收到指令后，开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断\n1. CPU收到中断信号后，停下当前线程，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器（内核缓冲区，页缓存，PageCache），然后再把寄存器里面的数据写入内存，**在数据传输期间CPU无法执行其它任务**\n\n![](https://camo.githubusercontent.com/df1a347469c3a252e8f1c1c433df9f77bf2771c32843e3baa2ff8c6939ce2aea/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539422542362545362538422542372545382542342539442f495f4f2532302545342542382541442545362539362541442e706e67)\n\n`直接内存访问 DMA（Direct Memory Access）`，**在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务**。\n\n![](https://camo.githubusercontent.com/8ac4065e585443e68b00b67616e4b656dc4b3a838e7dbd3d857053d3de9f3509/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539422542362545362538422542372545382542342539442f44524d253230495f4f2532302545382542462538372545372541382538422e706e67)\n\n具体过程：\n\n- 用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入`阻塞状态`；\n- 操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；\n- DMA 进一步将 I/O 请求发送给磁盘；\n- 磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；\n- DMA 收到磁盘的信号，**将磁盘控制器缓冲区中的数据拷贝到内核缓冲区**中，此时不占用 CPU，CPU 可以执行其他任务；\n- 当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；\n- CPU 收到 DMA 的信号，知道数据已经准备好，于是**将数据从内核拷贝到用户空间**，系统调用返回；\n\n可以看到，**CPU 不再参与「将数据从磁盘控制器缓冲区搬运到内核空间」的工作，这部分工作由 DMA 完成**，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。\n\n每个 I/O 设备里面都有自己的 DMA 控制器。\n"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cvsq1nl3zvk0",
                    "created": 1695718515100,
                    "text": "传统的文件传输",
                    "note": "传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。\n\n![](https://camo.githubusercontent.com/e062c452f7444b12475257d12723d627d9e3142f795c3567d021bbc089d22824/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539422542362545362538422542372545382542342539442f2545342542432541302545372542422539462545362539362538372545342542422542362545342542432541302545382542452539332e706e67)\n\n首先，**期间共发生了 4 次用户态与内核态的上下文切换**，因为发生了两次系统调用，一次是 `read()` ，一次是 `write()`，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。\n\n上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。\n\n其次，**还发生了 4 次数据拷贝**，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的：\n\n- 第一次拷贝，把`磁盘`上的数据拷贝到操作系统`内核的缓冲区`里，这个拷贝的过程是通过 DMA 搬运的。\n- 第二次拷贝，把`内核缓冲区`的数据拷贝到`用户的缓冲区`里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。\n- 第三次拷贝，把刚才拷贝到`用户的缓冲区`里的数据，再拷贝到`内核的 socket 的缓冲区`里，这个过程依然还是由 CPU 搬运的。\n- 第四次拷贝，把`内核的 socket 缓冲区`里的数据，拷贝到`网卡的缓冲区`里，这个过程又是由 DMA 搬运的。\n"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cvsq62i7r740",
                    "created": 1695718861033,
                    "text": "如何优化文件传输的性能",
                    "note": "由上节可知，要想提高文件传输的性能，就需要减少`用户态与内核态的上下文切换`和`内存拷贝`的次数。\n"
                },
                "children": [
                    {
                        "data": {
                            "id": "cvsq66z4gk80",
                            "created": 1695718870762,
                            "text": "用户态与内核态的上下文切换",
                            "note": "读取磁盘数据的时候，之所以要发生上下文切换，这是**因为用户空间没有权限操作磁盘或网卡**，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的**系统调用**函数。\n\n而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。\n\n所以，要想减少上下文切换到次数，就要**减少系统调用的次数**。\n"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cvsq71a8le80",
                            "created": 1695718936738,
                            "text": "数据拷贝",
                            "note": "传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。\n\n因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此**用户的缓冲区是没有必要存在的**。\n"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cvsq8v46fj40",
                    "created": 1695719080039,
                    "text": "实现零拷贝",
                    "note": "零拷贝技术实现的方式通常有 2 种：\n\n- mmap + write\n- sendfile\n"
                },
                "children": [
                    {
                        "data": {
                            "id": "cvsq96pspag0",
                            "created": 1695719105291,
                            "text": "mmap + write",
                            "note": "`read()` 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 `mmap()` 替换 read() 系统调用函数。\n\n```c\nbuf = mmap(file, len);\nwrite(sockfd, buf, len);\n```\n\n`mmap()` 系统调用函数会直接把内核缓冲区里的数据**映射**到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。\n\n![](https://camo.githubusercontent.com/dfb44da621f2c5633e7c4008953787577084c5a91769b78e9a84bbc3d9dcb364/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539422542362545362538422542372545382542342539442f6d6d61702532302b25323077726974652532302545392539422542362545362538422542372545382542342539442e706e67)\n\n应用进程再调用 `write()`时，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在**内核态，由 CPU 来搬运数据**；\n\n这不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。\n"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cvsq99zyhpc0",
                            "created": 1695719112436,
                            "text": "sendfile",
                            "note": "在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 `sendfile()`：\n\n```c\n#include <sys/socket.h>\nssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);\n```\n\n它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。\n\n![](https://camo.githubusercontent.com/d872f9a7064149c2fe390ea4e73e4b6b6bf4508c5400d1e9ed4a85e4ecea6afd/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539422542362545362538422542372545382542342539442f73656e66696c652d332545362541432541312545362538422542372545382542342539442e706e67)\n\n- 首先，它可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。\n- 其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。\n\n但是这还不是真正的零拷贝技术，如果网卡支持 `SG-DMA（The Scatter-Gather Direct Memory Access）`技术（和普通的 DMA 有所不同），可以**减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区**的过程。\n\n查看网卡是否支持 scatter-gather 特性：\n```sh\n$ ethtool -k eth0 | grep scatter-gather\nscatter-gather: on\n```\n"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cvsqkbk8yl40",
                            "created": 1695719977845,
                            "text": "真正的零拷贝",
                            "note": "从 Linux 内核 2.4 版本开始起，对于支持 SG-DMA 技术的网卡， sendfile() 系统调用的过程发生了点变化，具体过程如下：\n\n1. 第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；\n1. 第二步，缓冲区`描述符`和`数据长度`传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；\n\n![](https://camo.githubusercontent.com/43a3c1c58d5aeb096990c2b41138e8380e075a58da99a491660d3fa0f5e09261/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539422542362545362538422542372545382542342539442f73656e66696c652d2545392539422542362545362538422542372545382542342539442e706e67)\n\n这就是所谓的`零拷贝（Zero-copy）`技术，因为**没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的**。\n\n零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，**只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运**。\n\n所以，总体来看，**零拷贝技术可以把文件传输的性能提高至少一倍以上**。"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cvsquxpa9qo0",
                    "created": 1695720809681,
                    "text": "PageCache的作用",
                    "note": "文件传输过程中，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是`磁盘高速缓存（Disk Cache）中的页缓存（PageCache）`。\n\nDisk Cache 在 Linux 中有三种类型：\n\n1. dentry cache （目录项缓存）\n2. Page cache \n3. Buffer cache\n\n读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。于是，我们会通过 DMA 把磁盘里的数据搬运到内存里，这样就可以用读内存替换读磁盘。\n但是，内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。\n\n根据**局部性**原理，可以**用 PageCache 来缓存最近被访问的数据，当空间不足时淘汰最久未被访问的缓存**。\n\n所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。\n\nPageCache 的优点主要是两个：\n\n- 缓存最近被访问的数据；\n- 预读功能；\n\n但是，**在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能**。\n\n原因：\n\n-  PageCache 空间很快被这些大文件占满\n- 由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，导致下面两个问题：\n\t- PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；\n\t- PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；\n"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cvsr49la6gg0",
                    "created": 1695721540837,
                    "text": "大文件传输",
                    "note": "先看看最初的例子：\n![](https://camo.githubusercontent.com/0b960bbb85c9782900c41ddd4fcf467b631e25c6eee468ec21f9a48e3b7aaed1/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539422542362545362538422542372545382542342539442f254539253938254242254535254131253945253230494f2532302545372539412538342545382542462538372545372541382538422e706e67)\n进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回。\n\n对于阻塞的问题，可以用异步 I/O 来解决：\n![](https://camo.githubusercontent.com/6e3299a670cf6b94a1085128cd041861ad3474b2cc5c6337454c779340d32a44/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545392539422542362545362538422542372545382542342539442f254535254243253832254536254144254135253230494f2532302545372539412538342545382542462538372545372541382538422e706e67)\n\n它把读操作分为两部分：\n\n- 前半部分，内核向磁盘发起读请求，但是**可以不等待数据就位就可以返回**，于是进程此时可以处理其他任务；\n- 后半部分，当**内核将磁盘中的数据拷贝到进程缓冲区**后，进程将接收到内核的通知，再去处理数据；\n\n绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。\n\n**在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术**。\n\n所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：\n\n- 传输大文件的时候，使用「异步 I/O + 直接 I/O」；\n- 传输小文件的时候，则使用「零拷贝技术」；\n\n【ChatGPT】：\n异步 I/O（Asynchronous I/O）是指应用程序在发起 I/O 操作之后，不必等待 I/O 操作完成就可以继续执行其他任务。当 I/O 操作完成后，操作系统会通知应用程序，应用程序可以通过回调函数或其他方式获取 I/O 操作的结果。异步 I/O 通常使用操作系统提供的 aio 系列函数进行实现，例如 aio_read()、aio_write() 等。\n\n异步 I/O 的优点在于可以提高应用程序的并发性和响应性能，并且可以减少 CPU 的等待时间，从而提高 CPU 利用率。但是，异步 I/O 的缺点在于编程复杂度比较高，需要较多的代码处理回调函数、事件通知等。\n\n直接 I/O（Direct I/O），也称为无缓存 I/O（Cache Bypassing I/O），是指应用程序直接在文件和磁盘之间进行数据传输，跳过内核页缓存，将数据直接读取或写入磁盘。直接 I/O 通常使用 O_DIRECT 标志进行实现，例如 open()、read()、write() 等函数中的 O_DIRECT 参数。\n\n直接 I/O 的优点在于可以避免使用页缓存的额外开销，从而减少 CPU 和内存的开销，并且可以提高数据的一致性和实时性能。但是，直接 I/O 的缺点在于对磁盘的访问模式较为严格，必须保证读写操作的大小是块大小（通常为 512B 或 4KB）的倍数，否则可能会导致额外的开销和低效率。\n"
                },
                "children": []
            }
        ]
    },
    "template": "right",
    "theme": "classic",
    "version": "1.4.43"
}