{
    "root": {
        "data": {
            "id": "cub5hsxqgfc0",
            "created": 1690277859562,
            "text": "HTTP和其他协议的区别"
        },
        "children": [
            {
                "data": {
                    "id": "cub5hx5s7bk0",
                    "created": 1690277868756,
                    "text": "和 RPC 协议的区别",
                    "note": "纯裸 TCP 是不能直接拿来用的，你需要在这个基础上加入一些自定义的规则，用于区分消息边界。\n于是基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。\n注意：rpc不一定非要使用 TCP 作为底层协议。\n\n总结：\n- 纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义消息边界。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。\n- RPC 本质上不算是协议，而是一种调用方式，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，不一定非得基于 TCP 协议。\n- 从发展历史来说，HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。\n- RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 性能要更好，所以大部分公司内部都还在使用 RPC。\n- HTTP/2.0 在 HTTP/1.1 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。"
                },
                "children": [
                    {
                        "data": {
                            "id": "cub5ic5tgtk0",
                            "created": 1690277901410,
                            "text": "服务发现",
                            "note": "首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 IP 地址和端口。这个找到服务对应的 IP 端口的过程，其实就是服务发现。\n\n- 在 HTTP 中，你知道服务的域名，就可以通过 DNS 服务去解析得到它背后的 IP 地址，默认 80 端口。\n\n- 而 RPC 的话，一般会有专门的中间服务去保存服务名和IP信息，比如 Consul 或者 Etcd，甚至是 Redis。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如CoreDNS。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cub5j5s8okg0",
                            "created": 1690277965892,
                            "text": "底层连接形式",
                            "note": "- 以主流的 HTTP/1.1 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（Keep Alive），之后的请求和响应都会复用这条连接。\n\n- 而 RPC 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cub5jqbbc4g0",
                            "created": 1690278010581,
                            "text": "传输的内容",
                            "note": " RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。\n \n上面说的 HTTP，其实特指的是现在主流使用的 HTTP/1.1，HTTP/2 在前者的基础上做了很多改进，所以性能可能比很多 RPC 协议还要好，甚至连 gRPC 底层都直接用的 HTTP/2。"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cub81cqamzs0",
                    "created": 1690285033787,
                    "text": "和 websocket 协议的区别",
                    "note": "\t怎么样才能在用户不做任何操作的情况下，网页能收到消息并发生变更。\n\n- 使用 HTTP 不断轮询。最常见的解决方案是，网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。\t\n- 长轮询。如果我们的 HTTP 请求将超时设置的很大，比如 30 秒，在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。\n\n### websocket\nTCP 连接的两端，同一时间里，双方都可以主动向对方发送数据。这就是所谓的全双工。\n\n而现在使用最广泛的HTTP/1.1，也是基于TCP协议的，同一时间里，客户端和服务器只能有一方主动发数据，这就是所谓的半双工。\n\nwebsocket 适用于需要服务器和客户端（浏览器）频繁交互的大部分场景\n为了兼容使用场景。浏览器在 TCP 三次握手建立连接之后，都统一使用 HTTP 协议先进行一次通信。\n\n如果此时是普通的 HTTP 请求，那后续双方就还是继续用 HTTP 协议进行交互。\n如果这时候是想建立 WebSocket 连接，就会在 HTTP 请求里带上一些特殊的header 头，如下：\n\n```\nConnection: Upgrade\nUpgrade: WebSocket\nSec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\\r\\n\n```\n\n如果服务器正好支持升级成 WebSocket 协议。就会走 WebSocket 握手流程，同时根据客户端生成的 base64 码，用某个公开的算法变成另一段字符串，放在 HTTP 响应的 Sec-WebSocket-Accept 头里，同时带上101状态码（协议切换），发回给浏览器。HTTP 的响应如下：\n```\nHTTP/1.1 101 Switching Protocols\\r\\n\nSec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\\r\\n\nUpgrade: WebSocket\\r\\n\nConnection: Upgrade\\r\\n\n```\n\n总结\n- TCP 协议本身是全双工的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是半双工的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。\n- 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用定时轮询或者长轮询的方式实现服务器推送(comet)的效果。\n- 对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。\n- WebSocket 和 socket 几乎没有任何关系，只是叫法相似。\n- 正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。\n"
                },
                "children": []
            }
        ]
    },
    "template": "right",
    "theme": "classic",
    "version": "1.4.43"
}