{
    "root": {
        "data": {
            "id": "cw3vpaib3pc0",
            "created": 1696851632445,
            "text": "AOF",
            "note": "虽说 Redis 是内存数据库，但是它为数据的持久化提供了两个技术。分别是「AOF 日志和 RDB 快照」。\n\n这两种技术都会用各用一个日志文件来记录信息，但是记录的内容是不同的。\n\n- AOF 文件的内容是操作命令；\n- RDB 文件的内容是二进制数据。\n\n补充文章：[Redis 设计与实现--AOF](https://redisbook.readthedocs.io/en/latest/internal/aof.html)\n"
        },
        "children": [
            {
                "data": {
                    "id": "cw3vqdk4px40",
                    "created": 1696851717450,
                    "text": "AOF 日志",
                    "note": "若 Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里，然后重启 Redis 的时候，先去读取这个文件里的命令，并且执行它，就相当于恢复了缓存数据。这就是 Redis 里的 `AOF(Append Only File)` 持久化功能，注意**只会记录写操作命令，读操作命令是不会被记录的**，因为没意义。\n\n AOF 持久化功能默认是不开启的，需要我们修改 `redis.conf` 配置文件中的以下参数：\n \n```\nappendonly\t\t\t  yes\nappendfilename\t\t\"redis.aof\"\n```\n\n记录在 AOF 日志里的内容如下图：\n![337021a153944fd0f964ca834e34d0f2](img/337021a153944fd0f964ca834e34d0f2.webp)\n\n`*3`表示当前命令有三个部分，每部分都是以`$+数字` 开头，后面紧跟着具体的命令、键或值。然后，这里的「数字」表示这部分中的命令、键或值一共有多少字节。例如，「$3 set」表示这部分有 3 个字节，也就是「set」命令这个字符串的长度。\n\nRedis 是**先执行写操作命令后，然后才将该命令记录到 AOF 日志里**，这么做其实有两个好处：\n\n- 第一个好处，避免额外的检查开销。\n先执行写操作命令再记录日志的话，只有在该命令执行成功后，才将命令记录到 AOF 日志里，这样就保证记录在 AOF 日志里的命令都是可执行并且是正确的。\n- 第二个好处，不会阻塞当前写操作命令的执行。\n\n潜在风险：\n\n- 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个**数据就会有丢失的风险**。\n- 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是**可能会给「下一个」命令带来阻塞风险**。\n因为将命令写入到日志的这个操作也是在主进程完成的（执行命令也是在主进程），也就是说这两个操作是同步的。\n"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cw3w30hxhc00",
                    "created": 1696852707752,
                    "text": "三种写回策略",
                    "note": "![4eeef4dd1bedd2ffe0b84d4eaa0dbdea](img/4eeef4dd1bedd2ffe0b84d4eaa0dbdea.webp)\n\n1. Redis 执行完写操作命令后，会将命令追加到 `server.aof_buf` 缓冲区；\n1. 然后通过 `write()` 系统调用，将 `aof_buf` 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 `page cache`，等待内核将数据写入硬盘；\n1. 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。\n\n在 `redis.conf` 配置文件中的 `appendfsync` 配置项可以有以下 3 种写回硬盘的策略，控制的就是上面说的第三步的过程：\n\n- `Always`，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；\n- `Everysec`，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；默认值。\n- `No`，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。\n\n这三种策略只是在控制 fsync() 函数的调用时机。\n\n- Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数；\n- Everysec 策略就会创建一个异步任务来执行 fsync() 函数；\n- No 策略就是永不执行 fsync() 函数;\n"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cw3wdsywngg0",
                    "created": 1696853553370,
                    "text": "AOF 重写",
                    "note": "Redis 为了避免 AOF 文件越写越大，提供了 `AOF 重写机制`，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。\n\nAOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。\n\n重写机制的妙处在于，尽管某个键值对被多条写命令反复修改，**最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对**。\n\n如果直接使用现有的 AOF 文件进行重写的话，假如 AOF 重写过程中失败了，现有的 AOF 文件就会造成污染，可能无法用于恢复使用。\n\n所以 AOF 重写过程，先重写到新的 AOF 文件，重写失败的话，就直接删除这个文件就好，不会对现有的 AOF 文件造成影响。\n\n用命令手动重写：\n```redis\n> BGREWRITEAOF\n```\n\n修改redis配置文件redis.conf，进行自动重写：\n```\nauto-aof-rewrite-percentage 100 #增长百分比为100时开启重写（默认是100）\n\nauto-aof-rewrite-min-size 64mb #当前aof文件大小大于这个值开启重写（默认是1M）\n```\n\n每次当serverCron（服务器周期性操作函数）函数执行时，它会检查以下条件是否全部满足，如果全部满足的话，就触发自动的AOF重写操作：\n\n- 没有BGSAVE命令（RDB持久化）/AOF持久化在执行；\n- 没有BGREWRITEAOF在进行；\n- 当前AOF文件大小要大于server.aof_rewrite_min_size（默认为1MB）(或者在redis.conf配置了auto-aof-rewrite-min-size大小)\n- 当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比（在配置文件设置了auto-aof-rewrite-percentage参数，不设置默认为100%）\n"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cw3whitt42o0",
                    "created": 1696853844751,
                    "text": "AOF 后台重写",
                    "note": "Redis 的重写 AOF 过程是很耗时的，所以由后台子进程 `bgrewriteaof` 来完成，这么做可以达到两个好处：\n\n- 子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而**避免阻塞主进程**；\n- 子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是**父子进程就有了独立的数据副本，就不用加锁来保证数据安全**。\n\n主进程在通过 fork 系统调用生成 bgrewriteaof 子进程时，操作系统会把主进程的**页表**复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，**两者的虚拟空间不同，但其对应的物理空间是同一个，这样能够节约物理内存资源**。，页表对应的页表项的属性会标记该物理内存的权限为**只读**。\n\n不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发**缺页中断**，这个缺页中断是由于违反权限导致的，然后操作系统会在「缺页异常处理函数」里进行**物理内存的复制**，并重新设置其内存映射关系，将父子进程的内存读写权限设置为**可读写**，最后才会对内存进行写操作，这个过程被称为`写时复制 (Copy On Write)`。\n\n所以，有两个阶段会导致阻塞父进程：\n\n- 创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；\n- 创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；\n\n如果重写过程中主进程修改了已经存在 key-value，就会发生写时复制，注意这里**只会复制主进程修改的物理内存数据，没修改物理内存还是与子进程共享的**。\n\n所以如果这个阶段修改的是一个 `bigkey`，这时复制的物理内存数据的过程就会比较耗时，有阻塞主进程的风险。\n"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cw3wpjpyhso0",
                    "created": 1696854473608,
                    "text": "AOF 重写时的一致性",
                    "note": "因为子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。\n\n为了解决这个问题， Redis 增加了一个 `AOF 重写缓存`， 这个缓存在 fork 出子进程之后开始启用， Redis 主进程在接到新的写命令之后， 它会同时将这个写命令写入到`AOF 缓冲区`和`AOF 重写缓冲区`：\n\n![AOF 重写缓冲区](img/AOF 重写缓冲区.webp)\n\n当子进程完成 AOF 重写工作（扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志）后，会向主进程发送一条**信号**，信号是进程间通讯的一种方式，且是异步的。\n\n主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：\n\n- 将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；\n- 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。\n\n信号函数执行完后，主进程就可以继续像往常一样处理命令了。\n\n在整个 AOF 后台重写过程中，会对主进程造成阻塞的情况：\n\n- 创建子进程的途中，复制父进程的页表等数据结构\n- 发生写时复制\n- 信号处理函数执行时也会对主进程造成阻塞\n"
                },
                "children": []
            }
        ]
    },
    "template": "right",
    "theme": "classic",
    "version": "1.4.43"
}