# 第2章 关系数据库

按照数据模型的三要素，关系模型由三部分组成：**关系数据结构、关系操作集合和关系完整性约束**。

## 2.1 关系数据结构及形式化定义

### 2.1.1 关系

关系模型的数据结构非常简单，只包含单一的数据结构——关系。

下面从集合论的角度给出关系数据结构的形式化定义。

- 域（domain）：域是一组具有相同数据类型的值的集合。
- 笛卡尔积

  给定一组域 $D_1, D_2,...,D_n$，允许其中某些域是相同的，$D_1,D_2,...,D_n$ 的笛卡尔积为 $D_1 \times D_2 \times ... \times D_n = {(d_1,d_2,...,d_n) | d_i \in D_i, i=1,2,...,n}$

  其中，每一个元素 $(d_1,d_2,...,d_n)$ 叫作一个 n 元组，简称`元组`。元素中的每一个值 $d_i$ 叫做一个`分量`  。一个域允许的不同取值个数称为这个域的`基数`。

  若 $D_i(i=1,2,...,n)$ 为有限集，其基数为 $m_i(i=1,2,...,n)$，则$D_1 \times D_2 \times ... \times D_n$的基数 M 为 $M = \Pi_{i=1}^{n} m_i$。

  笛卡尔积可表示为一张二维表，表中每行对应一个元组，每列的值来自一个域。

- 关系

  $D_1 \times D_2 \times ... \times D_n$的子集叫做在域 $D_1, D_2,...,D_n$ 上的关系，表示为 $R(D_1, D_2,...,D_n)$，这里 R 表示关系的名字，n 是关系的目或度（degree）。

  关系中的每个元素是关系中的元组，通常用 $t$ 表示。

  当 n=1 时，称该关系为一元/单元关系。

  当 n=2 时，称该关系为二元关系。

  关系是笛卡尔积的有限子集，所以关系也是一张二维表，表的每行对应一个元组，每列对应一个域。由于域可以相同，为了加以区分，必须为每列取一个名字，称为`属性`。n 目关系必有 n 个属性。

  若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为`候选码`。

  若一个关系由多个候选码，则选定其中一个为`主码`（primary key）。

  候选码的诸属性称为`主属性`。不包含在任何候选码中的属性称为`非主属性`或`非码属性`。最简单的情况下，候选码只包含一个属性；最极端的情况下，关系模式的所有属性是这个关系的候选码，称为`全码`（all-key）。

  一般来说，$D_1, D_2,...,D_n$ 的笛卡尔积是没有实际意义的，只有它的某个真子集才有实际意义。

关系可以有三种类型：

- 基本关系（基本表、基表）：是实际存在的表，是实际存储数据的逻辑表示
- 查询表：是查询结果对应的表
- 视图表：是由基本表或其它视图表导出的表，是虚表，不对应实际存储的数据

基本关系有以下 6 条性质：

1. 列是同质的，即每列中的分量是同一类型的数据，来自同一个域。
2. 不同的列可出自同一个域，称其中的每一列为一个属性，不同的属性名要给予不同的属性名。比如导师属性和研究生属性都从 person 域中取值，为了避免混淆，必须给这两个属性不同的属性名。
3. 列的顺序无所谓。
4. 任意两个元组的候选码不能取相同的值。
5. 分量必须取原子值，即每一行都必须是不可分的数据项。简而言之就是不能有“表中表”。

### 2.1.2 关系模式

关系数据库中，**关系模式是型，关系是值**。关系是元组的集合，因此关系模式必须指出这个元组集合的结构，即它由哪些属性构成，这些属性来自哪些域，以及属性和域之间的映像关系。

关系的描述称为`关系模式`（relation schema）。可以形式化地表示为 $R(U, D, DOM, F)$，其中 R 为关系名，U 为组成该关系的属性名集合，D 为 U 中属性所来自的域，DOM 为属性向域的映像集合，F 为属性间数据的依赖关系集合。属性间数据的依赖关系在第 6 章讨论。

### 2.1.3 关系数据库

在关系模型中，实体以及实体之间的联系都是用关系来表示的。

关系数据库的型也称为关系数据库模式，是对关系数据库的描述。关系数据库模式包括若干域的定义，以及在这些域上定义的若干关系模式。

关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。

### 2.1.4 关系模型的存储结构

表是关系数据的逻辑模型。在关系数据库的物理组织中，有的关系数据库管理系统将物理数据组织交个操作系统完成；有的从操作系统申请若干个文件，子集划分文件空间，组织表、索引等存储结构，并进行存储管理。

## 2.2 关系操作

### 2.2.1 基本的关系操作

关系模型中常用的关系操作包括 查询操作（query） 和 插入（insert）、删除（delete）、修改（update）操作 两大部分。

查询操作又可分为 【选择（select）、投影（project）、并（union）、差（except）、笛卡尔积】、连接（join）、除（divide）、交（intersection） 等，其中前五种是基本操作。其它操作可以用基本操作来定义和导出。

关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合的方式。相应地，非关系数据模型的数据操作方式称为一次一记录的方式。

### 2.2.2 关系数据语言的分类

早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为关系代数和关系演算。

关系代数用对关系的运算来表达查询要求，关系演算用谓词来表达查询要求。

关系演算按谓词变元的基本对象是元组变量还是域变量分为元组关系演算和域关系演算。

一个关系数据语言能够表示关系代数可以表示的查询，称为具有完备的表达能力，简称关系完备性。关系代数、元组关系演算和域关系演算三种语言在表达能力上是等价的，都具有完备的表达能力。

这三种语言均是抽象的查询语言。

还有一种介于关系代数和关系演算之间的`结构化查询语句（Structured Query Language，SQL）`。SQL 是集 查询、数据定义语言、数据操纵语言和数据控制语言 于一体的关系数据语言。

因此，关系数据可分为三类语言：

- 关系代数语言
- 关系演算语言

  - 元组关系演算语言
  - 域关系演算语言

- 具有关系代数和关系演算双重特点的语言（如 SQL）

**DDL（Data Definition Language）** 是SQL语言中的一部分，主要用于定义和管理SQL数据库中的表以及与这些表相关的对象。DDL包括以下几种操作：

- **CREATE**：此命令用于创建数据库或其对象（如表，视图，索引，存储过程，函数等）。
- **ALTER**：此命令用于在数据库中对现有数据库对象进行更改。可以使用ALTER命令来添加，删除或修改表的字段，也可以用来更改表的名称。
- **DROP**：此命令用于删除整个数据库，或者数据库中的一些对象。例如，可以用DROP TABLE命令删除一个表。
- **TRUNCATE**：此命令用于删除表中的所有记录，但不删除表本身。
- **RENAME**：此命令用于重命名数据库对象。

在执行DDL语句后，系统不需要额外的事务处理，因为这些语句直接对数据库的结构进行操作。因此，它们立即生效，且不可回滚。

**DML（Data Manipulation Language）** 用于处理数据库中的数据。主要包括以下几种操作：

- **SELECT**：查询数据库中的数据。
- **INSERT**：将新数据插入数据库表中。
- **UPDATE**：修改数据库表中的数据。
- **DELETE**：从数据库表中删除数据。

注意，DML操作并不会立即改变数据库，除非你提交了这些操作。否则，你有权回滚或撤销所做的更改。

**DCL（Data Control Language）** 包含控制数据库访问和权限的命令。以下是两个主要的DCL命令：

- **GRANT**：提供用户或角色对数据库对象（如表，视图，索引等）的权限。
- **REVOKE**：撤销用户或角色对数据库对象的权限。

## 2.3 关系的完整性

关系模型的完整性规则是对关系的某种约束条件。也就是说关系的值随着时间变化时应该满足一些约束条件。

关系模型中有三类完整性约束：

- 实体完整性
- 参照完整性
- 用户定义完整性

前两个是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。

### 2.3.1 实体完整性

**规则 2.1 实体完整性规则**：若属性（一个或一组属性）A 是基本关系 R 的主属性，则 A 不能取空值（null value）。

实体完整性规则说明如下：

1. 实体完整性是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。例如学生关系对应于学生的集合。
2. 现实世界中的实体是可区分的，即它们具有某种唯一性标识。
3. 相应地，关系模型中以主码作为唯一性标识。
4. 主码中的属性即主属性不能取空值。

总结：现实世界关系对应关系表，关系表必须有主键且主键不能为空。

### 2.3.2 参照完整性

关系与关系之间存在着相互引用、相互约束的情况。

**定义2.5** 设 F 是基本关系 R 的一个或一组属性，但不是关系 R 的码，$K_s$ 是基本关系 S 的主码。如果 F 与 $K_s$ 对应，则称 F 是 R 的外码（foreign key），并称基本关系 R 为参照关系，基本关系 S 为被参照关系或目标关系。关系 R 和 S 不一定是不同的关系。

参照完整性就是定义外码与主码之间的引用规则。

**规则 2.2 参照完整性规则**：若属性（或属性组）F 是基本关系 R 的外码，它与基本关系 S 的主码 $K_s$ 相对应（R 与 S 不一定是不同的关系），则对于 R 中每个元组在 F 上的值必须：

- 或者取空值（F 的每个属性值都为空值）
- 或者等于 S 中某个元组的主码值

总结：就是规定外键必须全为空值或者必须有对应的主键（可以是本表或其它表的主键）。

### 2.3.3 用户定义的完整性

用户定义的完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。

## 2.4 关系代数

关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。

任何一种运算都是将一定的运算符作用于一定的运算对象上，所以运算的三大要素是：

- 运算对象
- 运算符
- 运算结果

关系代数的运算对象和运算结果都是关系。

关系代数用到的两类运算符：

![](img/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6.png)

关系代数的运算按运算符的不同可分为：

- 传统的集合运算。将关系看出元组的集合，其运算是从行的角度来进行的。
- 专门的关系运算。不仅涉及行，也涉及列。比较运算符和逻辑运算符是用来辅助专门的关系运算符进行操作的。

### 2.4.1 传统的集合运算

传统的集合运算是二目运算，包括 【并、差、交、笛卡尔积】。

$$
S \cap R = S-(S-R)
$$

### 2.4.2 专门的关系运算

【选择、投影、连接、除】运算等。

ChatGPT4 关于“象集”的解释：

> 在数据库中，"象集"的概念基本上涉及两个操作：一次选择运算和一次投影运算。

假设我们有一个关系模式R(X, Y)，其中X和Y代表两个互为补集的属性集。对于遵循模式R的某个关系A，象集的本质是先选择出所有X属性中x=x1的那些行，然后投影（选择）出不包含x1的那些列。

举一个例子，假设我们有一个学生表，包含学生ID，姓名和年级。如果我们要查找所有二年级学生的姓名，那么"二年级"就是我们要在"年级"属性上选择的值，"姓名"就是我们要投影的列。所以，“二年级学生的象集”就是所有二年级学生的姓名。

这就是“象集”的基本概念。简单来说，就是关于特定属性值的查询结果。

书上的象集：

![](img/%E8%B1%A1%E9%9B%86.png)

- 选择。选择又称为限制（restriction）。它是在关系 R 中选择满足给定条件的元组。
- 投影（projection）。从 R 中选择若干属性列组成新的关系。是从列的角度进行的运算。
- 连接（join）。从两个关系的笛卡尔积中选取属性间满足一定条件的元组。有两种最重要也最常用的连接:

  - 等值连接
  - 自然连接，是一种特殊的等值连接。与等值连接不同的是 自然连接在结果中会把重复的属性列去掉。同时从行和列的角度进行运算。  
    两个关系做自然连接时，关系 R 中的某些元组可能在 S 中不存在公共属性值上相等的元组，造成在操作时这些元组被舍弃了；同样，S 中某些元组也可能被舍弃。这些被舍弃的元组称为`悬浮元组。`  
    如果把悬浮元组也保存在结果中，而其他属性上填空值，就叫做`外连接`。若只保留左边关系中的悬浮元组就叫做`左外连接`。也就是保留左边的属性就是左外连接。

- 除运算（division）。关系 R 除以关系 S 的结果为 T，则 T 包含所有在 R 中单不在 S 中的属性及其值，且 T 的元组与 S 的元组的所有组合都在 R 中。就是一个集合排除另一个集合。同时从行和列的角度进行运算。

![](img/%E7%94%A8%E8%B1%A1%E9%9B%86%E5%AE%9A%E4%B9%89%E9%99%A4%E6%B3%95.png)

【选择（select）、投影（project）、并（union）、差（except）、笛卡尔积】这五种是基本的运算。连接（join）、除（divide）、交（intersection） 可以用基本运算来表达。

关系代数中，这些运算经有限次复合后形成的表达式称为`关系代数表达式`。

## 2.5 关系演算

描述具体语言语法，略。