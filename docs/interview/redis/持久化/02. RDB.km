{
    "root": {
        "data": {
            "id": "cw4j6zlh7fs0",
            "created": 1696917904775,
            "text": "RDB"
        },
        "children": [
            {
                "data": {
                    "id": "cw4j9ew7n9k0",
                    "created": 1696918094804,
                    "text": "RDB 快照",
                    "note": "RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。\n\n因此在 Redis 恢复数据时，RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。**Redis 的快照是全量快照**。\n\n手动执行：\n\n- `save` 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会**阻塞主线程**；\n- `bgsave` 命令，会创建一个子进程来生成 RDB 文件，这样可以**避免主线程的阻塞**；\n\n通过配置文件每隔一段时间自动执行一次 `bgsave` 命令，默认会提供以下配置：\t\n```\nsave 900 1\nsave 300 10\nsave 60 10000\n```\n\n只要满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：\n\n- 900 秒之内，对数据库进行了至少 1 次修改；\n- 300 秒之内，对数据库进行了至少 10 次修改；\n- 60 秒之内，对数据库进行了至少 10000 次修改。"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cw4kddadsc80",
                    "created": 1696921225874,
                    "text": "数据一致性",
                    "note": "执行 `bgsave` 过程中，Redis **依然可以继续处理操作命令**。关键的技术就在于`写时复制技术（Copy-On-Write, COW）`。\n\n执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个。\n\n只有在发生修改内存数据的情况时，物理内存才会被复制一份。\n\n当主线程（父进程）对这些共享的内存数据也都是**只读操作，那么，主线程（父进程）和 bgsave 子进程相互不影响**。\n\n但是，如果主线程（父进程）要**修改共享数据**里的某一块数据（比如键值对 A）时，就会发生**写时复制，于是这块数据的物理内存就会被复制一份（键值对 A'），然后主线程在这个数据副本（键值对 A'）进行修改操作**。与此同时，bgsave **子进程可以继续把原来的数据（键值对 A）写入到 RDB 文件**。\n\n所以，**发生了写时复制后，RDB 快照保存的是原本的内存数据**。\n\n存在的问题：\n\n- 如果 Redis 出现宕机等情况，则意味着最多可能丢失配置的时间间隔数的数据。\n- 如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。\n- 在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的数据的物理内存就会被复制一份。那么极端情况下，如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍。\n"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cw4l67f8f680",
                    "created": 1696923485667,
                    "text": "RDB 和 AOF \n混用",
                    "note": "尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：\n\n- 如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；\n- 如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。\n\nRedis 4.0 提出`混合使用 AOF 日志和内存快照`，也叫`混合持久化`。\n\n开启的配置内容：\n```\naof-use-rdb-preamble yes\n```\n\n混合持久化**工作在 AOF 日志重写过程**。\n\n当开启了混合持久化时，在 AOF 重写日志时，**fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件**，然后**主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件**，写入完成后通知**主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件**。\n\n使用了混合持久化，AOF 文件的**前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据**。\n\n优点：\n\n- 重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样**加载的时候速度会很快**。\n- 加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以**使得数据更少的丢失**。\n"
                },
                "children": []
            }
        ]
    },
    "template": "right",
    "theme": "classic",
    "version": "1.4.43"
}