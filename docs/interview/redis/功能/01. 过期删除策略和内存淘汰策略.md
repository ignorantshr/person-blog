
[TOC]
# 过期删除策略和内存淘汰策略

## 过期删除

Redis 是可以对 key 设置过期时间的，因此需要有相应的机制将已过期的键值对删除，而做这个工作的就是过期键值删除策略。


### 如何判定 key 已过期了

Redis 有一个**过期字典（expires dict）**，里面保存了所有 key 的过期时间。

过期字典存储在 redisDb 结构中，如下：：
```c
typedef struct redisDb {
    dict *dict;    /* 数据库键空间，存放着所有的键值对 */
    dict *expires; /* 键的过期时间 */
    ....
} redisDb;
```

过期字典数据结构结构如下：

- 过期字典的 key 是一个指针，指向某个键对象；
- 过期字典的 value 是一个 long long 类型的整数，这个整数保存了 key 的过期时间；

![](https://camo.githubusercontent.com/f69e77de901006753bfdb08978b7e49b5fe6f95240e75710c01e9d1fc4870eec/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f72656469732f2545382542462538372545362539432539462545372541442539362545372539352541352f2545382542462538372545362539432539462545352541442539372545352538352542382545362539352542302545362538442541452545372542422539332545362539452538342e706e67)

当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：

1. 如果不在，则正常读取键值；
1. 如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。



### 常见的过期删除策略

先看下常见的三种过期删除策略：

- 定时删除；
- 惰性删除；
- 定期删除；

> 定时删除策略

在设置 key 的过期时间时，同时创建一个**定时事件**，当时间到达时，由事件处理器自动执行 key 的删除操作。

优点：

可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除**对内存是最友好的**。

缺点：

在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略**对 CPU 不友好**。

> 惰性删除

**不主动删除过期键**，每次从数据库访问 key 时，都**检测 key 是否过期**，如果过期则删除该 key。

优点：

因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略**对 CPU 时间最友好**。

缺点：

如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略**对内存不友好**。

> 定期删除

每隔一段时间**随机从数据库中取出一定数量的 key 进行检查**，并删除其中的过期 key。

优点：

通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。

缺点：

- 内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。
- **难以确定删除操作执行的时长和频率**。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对 CPU 不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。

### Redis 过期删除策略

Redis 选择 **惰性删除+定期删除** 两种策略配合使用，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。

#### 惰性删除

Redis 的惰性删除策略由 `db.c` 文件中的 `expireIfNeeded` 函数实现，代码如下：
```c
int expireIfNeeded(redisDb *db, robj *key) {
    // 判断 key 是否过期
    if (!keyIsExpired(db,key)) return 0;
    ....
    /* 删除过期键 */
    ....
    // 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除；
    return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :
                                         dbSyncDelete(db,key);
}
```

惰性删除流程：
![](https://camo.githubusercontent.com/6b7268a7cf6df28b3b48cc9a1e82a37c7beae6589a499596f3e4c9a5a0f8477d/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f72656469732f2545382542462538372545362539432539462545372541442539362545372539352541352f2545362538332542302545362538302541372545352538382541302545392539392541342e6a7067)

#### 定期删除

> 检查的时间间隔

默认每秒进行 10 次过期检查一次数据库，此配置可通过 Redis 的配置文件 `redis.conf` 进行配置，配置键为 `hz`， 它的默认值是 `hz 10`。

> 随机抽查的数量

定期删除的实现在 `expire.c` 文件下的 `activeExpireCycle` 函数中，其中随机抽查的数量由 [`ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP`](https://github.com/redis/redis/blob/unstable/src/expire.c#L107) 定义的，它是写死在代码中的，数值是 `20`。

定期删除的流程：

1. 从过期字典中随机抽取 20 个 key；
1. 检查这 20 个 key 是否过期，并删除已过期的 key；
1. 如果本轮检查的已过期 key 的数量，超过 5 个（20/4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。
1. 同时，Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。

![](https://camo.githubusercontent.com/29a81b0ef248a2306ff38dc2020a416a87956de8db2f9c714dba9742936485a9/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f72656469732f2545382542462538372545362539432539462545372541442539362545372539352541352f2545352541452539412545362539372542362545352538382541302545392539392541342545362542352538312545372541382538422e6a7067)

### 持久化时，对过期键会如何处理

Redis 持久化文件有两种格式：RDB（Redis Database）和 AOF（Append Only File）。

RDB 文件分为两个阶段：

- **RDB 文件生成阶段**：从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，**过期的键「不会」被保存到新的 RDB 文件中**，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。
- **RDB 加载阶段**：RDB 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况：
	- 如果 Redis 是「主服务器」运行模式的话，**在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键「不会」被载入到数据库中**。所以过期键不会对载入 RDB 文件的主服务器造成影响；
	- 如果 Redis 是「从服务器」运行模式的话，**在载入 RDB 文件时，不论键是否过期都会被载入到数据库中**。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。

AOF 文件也分为两个阶段：

- **AOF 文件写入阶段**：当 Redis 以 AOF 模式持久化时，**如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值**。
- **AOF 重写阶段**：执行 AOF 重写时，会对 Redis 中的键值对进行检查，**已过期的键不会被保存到重写后的 AOF 文件中**，因此不会对 AOF 重写造成任何影响。
### 主从模式中，对过期键会如何处理

当 Redis 运行在主从模式下时，**从库不会进行过期扫描，从库对过期的处理是被动的**。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。

从库的过期键处理依靠主服务器控制，**主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库**，从库通过执行这条 del 指令来删除过期的 key。

## 内存淘汰策略

当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行。

在配置文件 `redis.conf` 中，可以通过参数 `maxmemory <bytes>` 来设定最大运行内存。

- 在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。
- 在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。

### 内存淘汰策略

Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。

不进行数据淘汰：

- `noeviction` ：它表示**当运行内存超过最大设置内存时，不淘汰任何数据**，这时如果有新的数据写入，则会触发 OOM，但是如果没有数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。（Redis3.0 之后，默认的内存淘汰策略）

进行数据淘汰：

- 在设置了过期时间的数据中进行淘汰：

	- `volatile-random`：随机淘汰设置了过期时间的任意键值；
	- `volatile-ttl`：优先淘汰更早过期的键值。
	- `volatile-lru`（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；
	- `volatile-lfu`（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；

- 在所有数据范围内进行淘汰：

	- `allkeys-random`：随机淘汰任意键值;
	- `allkeys-lru`：淘汰整个键值中最久未使用的键值；
	- `allkeys-lfu`（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。

查看当前 Redis 的内存淘汰策略:
```
> config get maxmemory-policy
1) "maxmemory-policy"
2) "noeviction"
```

设置内存淘汰策略有两种方法：

- 方式一：通过`config set maxmemory-policy <策略>`命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。
- 方式二：通过修改 Redis 配置文件修改，设置`maxmemory-policy <策略>`，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。

### LRU 算法

`LRU` 全称是 Least Recently Used 翻译为**最近最少使用**，会选择淘汰最近最少使用的数据。

Redis 并没有使用链表方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：

- 需要用链表管理所有的缓存数据，这会带来额外的空间开销；
- 当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。

Redis 实现的是一种近似 LRU 算法，目的是为了更好的节约内存，它的实现方式是**在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间**。

当 Redis 进行内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。

Redis 实现的 LRU 算法的优点：

- 不用为所有的数据维护一个大链表，节省了空间占用；
- 不用在每次数据访问时都移动链表项，提升了缓存的性能；

但是 LRU 算法有一个问题，无法解决缓存污染问题，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。

因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。

### LFU 算法

`LFU` 全称是 Least Frequently Used 翻译为**最近最不常用**，LFU 算法是根据数据访问次数来淘汰数据的。

LFU 算法相比于 LRU 算法的实现，多记录了**数据的访问频次**的信息。Redis 对象的结构如下：

```c
typedef struct redisObject {
    ...
      
    // 24 bits，用于记录对象的访问信息
    unsigned lru:LRU_BITS;  
    ...
} robj;
```
其中的 `lru` 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。

- 在 LRU 算法中，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳。
- 在 LFU 算法中，Redis 对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)。
	- `ldt` 是用来记录 key 的访问时间戳；
	- `logc` 是用来记录 key 的访问频率，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的 logc 初始值为 5。

注意，logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 **logc 会随时间推移而衰减的**。

Redis 在访问 key 时，对于 logc 是这样变化的：

1. 先按照上次访问距离当前的时长，来对 logc 进行衰减；
	衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据访问频率来淘汰数据的，而不只是访问次数。
1. 然后，再按照一定概率增加 logc 的值。
	增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。

`redis.conf` 提供了两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：

- `lfu-decay-time` 用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为 1，值越大，衰减越慢；
- `lfu-log-factor` 用于调整 logc 的增长速度，默认值为 10，值越大，logc 增长越慢。

