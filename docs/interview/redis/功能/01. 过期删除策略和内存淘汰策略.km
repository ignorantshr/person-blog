{
    "root": {
        "data": {
            "id": "cw5ad1wbyug0",
            "created": 1696994549937,
            "text": "过期删除策略和内存淘汰策略",
            "expandState": "expand"
        },
        "children": [
            {
                "data": {
                    "id": "cw5axpavet40",
                    "created": 1696996168166,
                    "text": "过期删除",
                    "note": "Redis 是可以对 key 设置过期时间的，因此需要有相应的机制将已过期的键值对删除，而做这个工作的就是过期键值删除策略。\n\n"
                },
                "children": [
                    {
                        "data": {
                            "id": "cw5azygw0sw0",
                            "created": 1696996344849,
                            "text": "如何判定 key 已过期了",
                            "note": "Redis 有一个**过期字典（expires dict）**，里面保存了所有 key 的过期时间。\n\n过期字典存储在 redisDb 结构中，如下：：\n```c\ntypedef struct redisDb {\n    dict *dict;    /* 数据库键空间，存放着所有的键值对 */\n    dict *expires; /* 键的过期时间 */\n    ....\n} redisDb;\n```\n\n过期字典数据结构结构如下：\n\n- 过期字典的 key 是一个指针，指向某个键对象；\n- 过期字典的 value 是一个 long long 类型的整数，这个整数保存了 key 的过期时间；\n\n![](https://camo.githubusercontent.com/f69e77de901006753bfdb08978b7e49b5fe6f95240e75710c01e9d1fc4870eec/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f72656469732f2545382542462538372545362539432539462545372541442539362545372539352541352f2545382542462538372545362539432539462545352541442539372545352538352542382545362539352542302545362538442541452545372542422539332545362539452538342e706e67)\n\n当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：\n\n1. 如果不在，则正常读取键值；\n1. 如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。\n\n\n"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cw5b3o2pgyo0",
                            "created": 1696996635680,
                            "text": "常见的过期删除策略",
                            "note": "先看下常见的三种过期删除策略：\n\n- 定时删除；\n- 惰性删除；\n- 定期删除；\n\n> 定时删除策略\n\n在设置 key 的过期时间时，同时创建一个**定时事件**，当时间到达时，由事件处理器自动执行 key 的删除操作。\n\n优点：\n\n可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除**对内存是最友好的**。\n\n缺点：\n\n在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略**对 CPU 不友好**。\n\n> 惰性删除\n\n**不主动删除过期键**，每次从数据库访问 key 时，都**检测 key 是否过期**，如果过期则删除该 key。\n\n优点：\n\n因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略**对 CPU 时间最友好**。\n\n缺点：\n\n如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略**对内存不友好**。\n\n> 定期删除\n\n每隔一段时间**随机从数据库中取出一定数量的 key 进行检查**，并删除其中的过期 key。\n\n优点：\n\n通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。\n\n缺点：\n\n- 内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。\n- **难以确定删除操作执行的时长和频率**。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对 CPU 不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。\n"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cw5ds2dpb8o0",
                            "created": 1697004189780,
                            "text": "Redis 过期删除策略",
                            "note": "Redis 选择 **惰性删除+定期删除** 两种策略配合使用，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。\n"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cw5dxawn2v40",
                                    "created": 1697004600160,
                                    "text": "惰性删除",
                                    "note": "Redis 的惰性删除策略由 `db.c` 文件中的 `expireIfNeeded` 函数实现，代码如下：\n```c\nint expireIfNeeded(redisDb *db, robj *key) {\n    // 判断 key 是否过期\n    if (!keyIsExpired(db,key)) return 0;\n    ....\n    /* 删除过期键 */\n    ....\n    // 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除；\n    return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :\n                                         dbSyncDelete(db,key);\n}\n```\n\n惰性删除流程：\n![](https://camo.githubusercontent.com/6b7268a7cf6df28b3b48cc9a1e82a37c7beae6589a499596f3e4c9a5a0f8477d/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f72656469732f2545382542462538372545362539432539462545372541442539362545372539352541352f2545362538332542302545362538302541372545352538382541302545392539392541342e6a7067)\n"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cw5dxnyc4y00",
                                    "created": 1697004628561,
                                    "text": "定期删除",
                                    "note": "> 检查的时间间隔\n\n默认每秒进行 10 次过期检查一次数据库，此配置可通过 Redis 的配置文件 `redis.conf` 进行配置，配置键为 `hz`， 它的默认值是 `hz 10`。\n\n> 随机抽查的数量\n\n定期删除的实现在 `expire.c` 文件下的 `activeExpireCycle` 函数中，其中随机抽查的数量由 [`ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP`](https://github.com/redis/redis/blob/unstable/src/expire.c#L107) 定义的，它是写死在代码中的，数值是 `20`。\n\n定期删除的流程：\n\n1. 从过期字典中随机抽取 20 个 key；\n1. 检查这 20 个 key 是否过期，并删除已过期的 key；\n1. 如果本轮检查的已过期 key 的数量，超过 5 个（20/4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。\n1. 同时，Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。\n\n![](https://camo.githubusercontent.com/29a81b0ef248a2306ff38dc2020a416a87956de8db2f9c714dba9742936485a9/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f72656469732f2545382542462538372545362539432539462545372541442539362545372539352541352f2545352541452539412545362539372542362545352538382541302545392539392541342545362542352538312545372541382538422e6a7067)\n"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "cw5axt1ofy00",
                    "created": 1696996176317,
                    "text": "内存淘汰策略",
                    "note": "当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行。\n\n在配置文件 `redis.conf` 中，可以通过参数 `maxmemory <bytes>` 来设定最大运行内存。\n\n- 在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。\n- 在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。\n"
                },
                "children": [
                    {
                        "data": {
                            "id": "cw5f5bxz7g00",
                            "created": 1697008050441,
                            "text": "内存淘汰策略",
                            "note": "Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。\n\n不进行数据淘汰：\n\n- `noeviction` ：它表示**当运行内存超过最大设置内存时，不淘汰任何数据**，这时如果有新的数据写入，则会触发 OOM，但是如果没有数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。（Redis3.0 之后，默认的内存淘汰策略）\n\n进行数据淘汰：\n\n- 在设置了过期时间的数据中进行淘汰：\n\n\t- `volatile-random`：随机淘汰设置了过期时间的任意键值；\n\t- `volatile-ttl`：优先淘汰更早过期的键值。\n\t- `volatile-lru`（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；\n\t- `volatile-lfu`（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；\n\n- 在所有数据范围内进行淘汰：\n\n\t- `allkeys-random`：随机淘汰任意键值;\n\t- `allkeys-lru`：淘汰整个键值中最久未使用的键值；\n\t- `allkeys-lfu`（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。\n\n查看当前 Redis 的内存淘汰策略:\n```\n> config get maxmemory-policy\n1) \"maxmemory-policy\"\n2) \"noeviction\"\n```\n\n设置内存淘汰策略有两种方法：\n\n- 方式一：通过`config set maxmemory-policy <策略>`命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。\n- 方式二：通过修改 Redis 配置文件修改，设置`maxmemory-policy <策略>`，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。\n"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cw5f54tcat40",
                            "created": 1697008034923,
                            "text": "LRU 算法",
                            "note": "`LRU` 全称是 Least Recently Used 翻译为**最近最少使用**，会选择淘汰最近最少使用的数据。\n\nRedis 并没有使用链表方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：\n\n- 需要用链表管理所有的缓存数据，这会带来额外的空间开销；\n- 当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。\n\nRedis 实现的是一种近似 LRU 算法，目的是为了更好的节约内存，它的实现方式是**在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间**。\n\n当 Redis 进行内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。\n\nRedis 实现的 LRU 算法的优点：\n\n- 不用为所有的数据维护一个大链表，节省了空间占用；\n- 不用在每次数据访问时都移动链表项，提升了缓存的性能；\n\n但是 LRU 算法有一个问题，无法解决缓存污染问题，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。\n\n因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。\n"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cw5f8yn79so0",
                            "created": 1697008334948,
                            "text": "LFU 算法",
                            "note": "`LFU` 全称是 Least Frequently Used 翻译为**最近最不常用**，LFU 算法是根据数据访问次数来淘汰数据的。\n\nLFU 算法相比于 LRU 算法的实现，多记录了**数据的访问频次**的信息。Redis 对象的结构如下：\n\n```c\ntypedef struct redisObject {\n    ...\n      \n    // 24 bits，用于记录对象的访问信息\n    unsigned lru:LRU_BITS;  \n    ...\n} robj;\n```\n其中的 `lru` 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。\n\n- 在 LRU 算法中，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳。\n- 在 LFU 算法中，Redis 对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)。\n\t- `ldt` 是用来记录 key 的访问时间戳；\n\t- `logc` 是用来记录 key 的访问频率，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的 logc 初始值为 5。\n\n注意，logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 **logc 会随时间推移而衰减的**。\n\nRedis 在访问 key 时，对于 logc 是这样变化的：\n\n1. 先按照上次访问距离当前的时长，来对 logc 进行衰减；\n\t衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据访问频率来淘汰数据的，而不只是访问次数。\n1. 然后，再按照一定概率增加 logc 的值。\n\t增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。\n\n`redis.conf` 提供了两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：\n\n- `lfu-decay-time` 用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为 1，值越大，衰减越慢；\n- `lfu-log-factor` 用于调整 logc 的增长速度，默认值为 10，值越大，logc 增长越慢。\n"
                        },
                        "children": []
                    }
                ]
            }
        ]
    },
    "template": "right",
    "theme": "classic",
    "version": "1.4.43"
}