
[TOC]
# Redis 面试

## 认识 Redis

Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于**缓存，消息队列、分布式锁**等场景。

Redis 对数据类型的操作都是**原子性**的，因为执行命令由单线程负责的，不存在并发竞争的问题。

除此之外，Redis 还支持**事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制**等等。

## Redis 和 Memcached 的区别

共同点：

- 都是基于内存的数据库，一般都用来当做缓存使用。
- 都有过期策略。
- 两者的性能都非常高。

区别：

- Redis 支持的数据类型更丰富，而 Memcached 只支持最简单的 key-value 数据类型；
- Redis 支持数据的持久化，而 Memcached 没有持久化功能；
- Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；
- Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持；
## 为什么用 Redis 作为缓存

主要是因为 Redis 具备「高性能」和「高并发」两种特性。

1、Redis 具备高性能

第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。

如果 MySQL 中的对应数据改变的之后，同步改变 Redis 缓存中相应的数据即可，不过这里会有 Redis 和 MySQL 双写一致性的问题。参考 缓存->《数据库和缓存的一致性》。

2、 Redis 具备高并发

单台设备的 Redis 的 `QPS（Query Per Second，每秒钟处理完请求的次数）` 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。

所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

## Redis 数据结构

参考 数据类型-> 《数据结构》《数据类型》。
## Redis 线程模型

### Redis 是单线程吗

Redis 单线程指的是「接收客户端请求 解析请求 进行数据读写等操作 发送数据给客户端」这个过程是由一个线程（主线程）来完成的。这是常说 Redis 是单线程的原因。

但是，**Redis 程序并不是单线程的**，Redis 在启动的时候，是会启动**后台线程（BIO）**的：

- Redis 在 2.6 版本，会启动 2 个后台线程，分别处理**关闭文件**、**AOF 刷盘**这两个任务；
- Redis 在 4.0 版本之后，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 `lazyfree` 线程。例如执行 unlink key / flushdb async / flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。

因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。

后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。

关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：

- `BIO_CLOSE_FILE`，关闭文件任务队列：当队列有任务后，后台线程会调用 `close(fd)` ，将文件关闭；
- `BIO_AOF_FSYNC`，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 `fsync(fd)`，将 AOF 文件刷盘，
- `BIO_LAZY_FREE`，lazy free 任务队列：当队列有任务后，后台线程会 `free(obj)` 释放对象 / free(dict) 删除数据库所有对象 / free(skiplist) 释放跳表对象；

### Redis 单线程模式是怎样的

Redis 6.0 版本之前的单线模式如下图：

![](https://camo.githubusercontent.com/b4db78ba1ab8e71c5ffd4b4f431dbb35bc17d3481ad55d3a3a99ca7aa628515e/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f72656469732f2545352538352541422545382538322541312545362539362538372f72656469732545352538442539352545372542412542462545372541382538422545362541382541312545352539452538422e64726177696f2e706e67)

图中的蓝色部分是一个事件循环，是由主线程负责的，可以看到网络 I/O 和命令处理都是单线程。 Redis 初始化的时候，会做下面这几件事情：

- 首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务端 socket
- 然后，调用 bind() 绑定端口和调用 listen() 监听该 socket；
- 然后，将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。

初始化完后，主线程就进入到一个**事件循环函数**，主要会做以下事情：

- 首先，先调用**处理发送队列函数**，如果发送队列中有发送任务，就通过 `write` 函数将客户端发送缓存区里的数据发送出去，若此轮数据没有发送完，就会注册写事件处理函数，等待 `epool_wait` 发现可写后再处理。
- 接着，调用 `epool_wait` 函数等待事件的到来：
	- **连接事件**，则调用**连接事件处理函数**：调用`accept`获取已连接的 socket -> 调用  `epool_ctl` 将已连接的 socket 加入到 epoll -> 注册「读事件」处理函数。
    - **读事件**，则调用**读事件处理函数**：调用 read 获取客户端发送的数据 -> 解析命令 -> 处理命令 -> 将客户端对象添加到发送队列 -> 将执行结果写到发送缓存区等待发送。
    - **写事件**，则调用**写事件处理函数**：通过 write 函数将客户端发送缓存区的数据发送出去，若这一轮数据没有发送完，就会继续注册写事件处理函数，等待 `epool_wait` 发现可写后再处理。

### Redis 采用单线程为什么还这么快


[源码分析-为什么单线程的 Redis 如何做到每秒数万 QPS ？](https://mp.weixin.qq.com/s/oeOfsgF-9IOoT5eQt5ieyw)

之所以 Redis 采用单线程（网络 I/O 和执行命令）那么快，有如下几个原因：

- Redis 的大部分操作**都在内存中完成**，并且采用了**高效的数据结构**，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；
- Redis 采用单线程模型可以**避免了多线程之间的竞争**，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。
- Redis 采用了 **I/O 多路复用机制**处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。

### Redis 6.0 前后的单线程/多线程

单线程的程序是无法利用服务器的多核 CPU 的，早期 Redis 版本的主要工作（网络 I/O 和执行命令）使用单线程的原因是：

- **CPU 并不是制约 Redis 性能表现的瓶颈所在**，更多情况下是受到内存大小和网络I/O的限制
- 使用了单线程后，可维护性高，多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，**增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗**。

**在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求**，这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上。**但是对于命令的执行，Redis 仍然使用单线程来处理**。

Redis 6.0 版本支持的 I/O 多线程特性，默认情况下 I/O 多线程只针对发送响应数据（write client socket），并不会以多线程的方式处理读请求（read client socket）。

Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会额外创建 6 个线程（这里的线程数不包括主线程）：

- Redis-server ： Redis的主线程，主要负责执行命令；
- bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；
- io_thd_1、io_thd_2、io_thd_3：三个 I/O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I/O 多线程，用来分担 Redis 网络 I/O 的压力。
## Redis 持久化

参考《持久化》。
## Redis 高可用

参考《高可用》。
## Redis 过期删除与内存淘汰

参考《功能》。
## Redis 实战

### Redis 大 key

一般而言，下面这两种情况被称为大 key：

- String 类型的值大于 10 KB；
- Hash、List、Set、ZSet 类型的元素的个数超过 5000个；

大 key 会带来以下四种影响：

- **客户端超时阻塞**。由于 Redis 执行命令是单线程处理，在操作大 key 时会比较耗时。
- **引发网络阻塞**。每次获取大 key 产生的网络流量较大。
- **阻塞工作线程**。如果使用 del 删除大 key，会阻塞工作线程，没办法处理后续的命令。
- **内存分布不均**。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜的情况，部分有大 key 的 Redis 节点占用内存较多，QPS 也会比较大。
#### 如何找到大 key

1、redis-cli --bigkeys 查找大key

```redis
redis-cli -h 127.0.0.1 -p6379 -a "password" -- bigkeys
```

注意事项：

- 最好选择在从节点上执行该命令。因为主节点上执行时，会阻塞主节点；
- 如果没有从节点，那么可以选择在 Redis 实例业务压力的低峰阶段进行扫描查询，以免影响到实例的正常运行；或者可以使用 `-i` 参数控制扫描间隔，避免长时间扫描降低 Redis 实例的性能。

不足之处：

- 这个方法只能返回每种类型中最大的那个 bigkey，无法得到大小排在前 N 位的 bigkey；
- 对于集合类型来说，这个方法只统计集合元素个数的多少，而不是实际占用的内存量。但是，一个集合中的元素个数多，并不一定占用的内存就多。因为，有可能每个元素占用的内存很小，这样的话，即使元素个数有很多，总内存开销也不大；

2、使用 SCAN 命令查找大 key

使用 `SCAN` 命令对数据库扫描，然后用 `TYPE` 命令获取返回的每一个 key 的类型。

- 对于 String 类型，可以直接使用 `STRLEN` 命令获取字符串的长度，也就是占用的内存空间字节数。
- 对于集合类型来说，有两种方法可以获得它占用的内存大小：
	- 如果能够预先从业务层知道集合元素的平均大小，那么，可以使用下面的命令获取集合元素的个数，然后乘以集合元素的平均大小，这样就能获得集合占用的内存大小了。List 类型：LLEN 命令；Hash 类型：HLEN 命令；Set 类型：SCARD 命令；Sorted Set 类型：ZCARD 命令；
	- 如果不能提前知道写入集合的元素大小，可以使用 `MEMORY USAGE` 命令（需要 Redis 4.0 及以上版本），查询一个键值对占用的内存空间。

3、使用 RdbTools 工具查找大 key

使用 RdbTools 第三方开源工具，可以用来解析 Redis 快照（RDB）文件，找到其中的大 key。

```redis
rdb dump.rdb -c memory --bytes 10240 -f redis.csv
```


#### 如何删除大 key

释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。

所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。

1、分批次删除

- 对于删除大 Hash，使用 `hscan` 命令，每次获取 100 个字段，再用 `hdel` 命令，每次删除 1 个字段。
- 对于删除大 List，通过 `ltrim` 命令，每次删除少量元素。
- 对于删除大 Set，使用 `sscan` 命令，每次扫描集合中 100 个元素，再用 `srem` 命令每次删除一个键。
- 对于删除大 ZSet，使用 `zremrangebyrank` 命令，每次删除 top 100个元素。

2、异步删除

从 Redis 4.0 版本开始，可以采用异步删除法，用 `unlink` 命令代替 del 来删除。

这样 Redis 会将这个 key 放入到一个异步线程中进行删除，这样不会阻塞主线程。

除了主动调用 unlink 命令实现异步删除之外，我们还可以通过配置参数，达到某些条件的时候自动进行异步删除。

主要有 4 种场景，默认都是关闭的：
- `lazyfree-lazy-eviction`：表示当 Redis 运行内存超过 maxmeory 时，是否开启 lazy free 机制删除；
- `lazyfree-lazy-expire`：表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除；
- `lazyfree-lazy-server-del`：有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除；
- `slave-lazy-flush`：针对 slave (从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除。

### Redis 管道

使用管道技术（Pipeline）可以解决多个命令执行时的网络等待，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率。

但使用管道技术也要注意避免发送的命令过大，或管道内的数据太多而导致的网络阻塞。

要注意的是，管道技术本质上是**客户端**提供的功能，而非 Redis 服务器端的功能。

