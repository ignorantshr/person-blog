{
    "root": {
        "data": {
            "id": "cvauanct8ds0",
            "created": 1693902425095,
            "text": "CPU 是如何执行任务的"
        },
        "children": [
            {
                "data": {
                    "id": "cvaud0utl4g0",
                    "created": 1693902611210,
                    "text": "CPU 如何读写数据",
                    "note": "CPU 从内存中读取数据到 Cache 的时候，并不是一个字节一个字节读取，而是一块一块的方式来读取数据的，这一块一块的数据被称为 CPU Cache Line（缓存块），所以 **CPU Cache Line 是 CPU 从内存读取数据到 Cache 的单位**。\n\n读写数据参考上文《CPU Cache》。"
                },
                "children": [
                    {
                        "data": {
                            "id": "cvaui2h8dj40",
                            "created": 1693903006563,
                            "text": "伪共享",
                            "note": "因为多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为**伪共享（False Sharing）**。\n\n下面举例说明。\n\n现在假设有一个双核心的 CPU，这两个 CPU 核心并行运行着两个不同的线程，它们同时从内存中读取两个不同的数据，分别是类型为 long 的变量 A 和 B，这个两个数据的地址在物理内存上是连续的，如果 Cahce Line 的大小是 64 字节，并且变量 A 在 Cahce Line 的开头位置，那么这两个数据是位于同一个 Cache Line 中，又因为 CPU Cache Line 是 CPU 从内存读取数据到 Cache 的单位，所以这两个数据会被同时读入到了两个 CPU 核心中各自 Cache 中。\n![](https://camo.githubusercontent.com/429bd91e8c3a316e0789d4f4c79b2d4071c5ccf1f55401e4055ce8b1ce76939c/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f4350552545342542432541412545352538352542312545342542412541422f2545352539302538432545342542382538302545342542382541412545372542432539332545352541442539382545382541312538432e706e67)\n\n1. 假设 1 号核心绑定了线程 A，2 号核心绑定了线程 B，线程 A 只会读写变量 A，线程 B 只会读写变量 B。\n\n1. 1 号核心读取变量 A，由于 CPU 从内存读取数据到 Cache 的单位是 Cache Line，也正好变量 A 和 变量 B 的数据归属于同一个 Cache Line，所以 A 和 B 的数据都会被加载到 Cache，并将此 Cache Line 标记为「独占」状态。\n![](https://camo.githubusercontent.com/e42ce64c86c250fd31cdc63e8befc46c7c9fb5e04cf07179485bea2652085fd4/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f4350552545342542432541412545352538352542312545342542412541422f254535253838253836254536253945253930254534254243254141254535253835254231254534254241254142322e706e67)\n\n1.  接着，2 号核心开始从内存里读取变量 B，同样的也是读取 Cache Line 大小的数据到 Cache 中，此 Cache Line 中的数据也包含了变量 A 和 变量 B，此时 1 号和 2 号核心的 Cache Line 状态变为「共享」状态。\n![](https://camo.githubusercontent.com/17138c50fb333287593737e59db1c75a3deac3b83a1aed969bf49afe3fdaeaac/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f4350552545342542432541412545352538352542312545342542412541422f254535253838253836254536253945253930254534254243254141254535253835254231254534254241254142332e706e67)\n\n1. . 1 号核心需要修改变量 A，发现此 Cache Line 的状态是「共享」状态，所以先需要通过总线发送消息给 2 号核心，通知 2 号核心把 Cache 中对应的 Cache Line 标记为「已失效」状态，然后 1 号核心对应的 Cache Line 状态变成「已修改」状态，并且修改变量 A。\n![](https://camo.githubusercontent.com/a04930fc9d9de7d9321b7758c942bda1a4072ce2d74c406b95ca0d33791c3c12/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f4350552545342542432541412545352538352542312545342542412541422f254535253838253836254536253945253930254534254243254141254535253835254231254534254241254142342e706e67)\n\n1. 之后，2 号核心需要修改变量 B，此时 2 号核心的 Cache 中对应的 Cache Line 是已失效状态，另外由于 1 号核心的 Cache 也有此相同的数据，且状态为「已修改」状态，所以要先把 1 号核心的 Cache 对应的 Cache Line 写回到内存，然后 2 号核心再从内存读取 Cache Line 大小的数据到 Cache 中，最后把变量 B 修改到 2 号核心的 Cache 中，并将状态标记为「已修改」状态。\n![](https://camo.githubusercontent.com/14f3cf4c11915b865b691994112ad23fd17585c64fe5bfa4e3994de3d9fd05ef/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f4350552545342542432541412545352538352542312545342542412541422f254535253838253836254536253945253930254534254243254141254535253835254231254534254241254142352e706e67)\n\n虽然变量 A 和 B 之间其实并没有任何的关系，但是因为同时归属于一个 Cache Line，这个 Cache Line 中的任意数据被修改后，都会相互影响，从而出现 4. 和 5. 这两个步骤。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cvaupph6oao0",
                            "created": 1693903605175,
                            "text": "避免伪共享的方法",
                            "note": "对于多个线程共享的热点数据，即经常会修改的数据，应该避免这些数据刚好在同一个 Cache Line 中。\n避免 Cache 伪共享实际上是用空间换时间的思想，浪费一部分 Cache 空间，从而换来性能的提升。\n\nLinux的解决方案是使用 `__cacheline_aligned` 宏：\n![](https://camo.githubusercontent.com/1913a81b3e2ae2cbe8a2908dddfd6c6986c5bfcc12284232a48887af07c38673/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f4350552545342542432541412545352538352542312545342542412541422f7374727563745f74657374312e706e67)\n这样 a 和 b 变量就不会在同一个 Cache Line 中了，如下图：\n![](https://camo.githubusercontent.com/31146a23db010792be3350edcdc53616eed3b11876864750dc035d218d548b56/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f4350552545342542432541412545352538352542312545342542412541422f7374727563745f6162312e706e67)\n\n\nJava 并发框架 Disruptor 使用「字节填充 + 继承」的方式，来避免伪共享的问题：\n![](https://camo.githubusercontent.com/f922aad5fc247b900cf10c9020b0c6239bc661b266bfcfc6ae9fbb622e323a25/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f4350552545342542432541412545352538352542312545342542412541422f2545352541312541422545352538352538352545352541442539372545382538412538322e706e67)\n\n由于「前后」各填充了 7 个不会被读写的 long 类型变量，所以无论怎么加载 Cache Line，这整个 Cache Line 里都没有会发生更新操作的数据，于是只要数据被频繁地读取访问，就自然没有数据被换出 Cache 的可能，也因此不会产生伪共享的问题。"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cvauv2ue3eo0",
                    "created": 1693904026093,
                    "text": "CPU 如何选择线程的",
                    "note": "在 Linux 内核中，进程和线程都是用 `task_struct` 结构体表示的，区别在于线程的 task_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等。\n\n![](https://camo.githubusercontent.com/8440b65acf5c324fea7b537b763e18d9e3143a6def99aeb58e4ae48fe310c9a2/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f4350552545342542432541412545352538352542312545342542412541422f2545342542422542422545352538412541312e706e67)\nLinux 内核里的调度器，调度的对象就是 task_struct，接下来我们就把这个数据结构统称为**任务**。\n\n根据任务的优先级以及响应要求，主要分为两种，其中优先级的数值越小，优先级越高：\n\n- **实时任务**，对系统的响应时间要求很高，也就是要尽可能快的执行实时任务，优先级在 `0~99` 范围内的就算实时任务；\n- **普通任务**，响应时间没有很高的要求，优先级在 `100~139` 范围内都是普通任务级别；"
                },
                "children": [
                    {
                        "data": {
                            "id": "cvauyhc13gw0",
                            "created": 1693904292727,
                            "text": "调度类",
                            "note": "![](https://camo.githubusercontent.com/709983d1452e29196dc5932e20b0ecb6366d6ef89ddfe039ac7343f0194701aa/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f4350552545342542432541412545352538352542312545342542412541422f2545382542302538332545352542412541362545372542312542422e706e67)\n\nDeadline 和 Realtime 这两个调度类，都是应用于实时任务的，这两个调度类的调度策略合起来共有这三种，它们的作用如下：\n\n- `SCHED_DEADLINE`：是按照 `deadline` 进行调度的，距离当前时间点最近的 deadline 的任务会被优先调度；\n- `SCHED_FIFO`：对于相同优先级的任务，按**先来先服务**的原则，但是**优先级更高的任务，可以抢占低优先级的任务**，也就是优先级高的可以「插队」；\n- `SCHED_RR`：对于相同优先级的任务，**轮流**着运行，每个任务都有一定的时间片，当用完时间片的任务会被放到队列尾部，以保证相同优先级任务的公平性，但是**高优先级的任务依然可以抢占低优先级的任务**；\n\n而 Fair 调度类是应用于普通任务，都是由 CFS 调度器管理的，分为两种调度策略：\n\n- `SCHED_NORMAL`：普通任务使用的调度策略；\n- `SCHED_BATCH`：后台任务的调度策略，不和终端进行交互，因此在不影响其他需要交互的任务，可以适当降低它的优先级。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cvav18pbs2o0",
                            "created": 1693904509032,
                            "text": "完全公平调度",
                            "note": "对于普通任务来说，公平性最重要，在 Linux 里面，实现了一个基于 CFS 的调度算法，也就是**完全公平调度（Completely Fair Scheduling）**。\n\n这个算法的理念是想让分配给每个任务的 CPU 时间是一样，于是它为每个任务安排一个虚拟运行时间 `vruntime`，如果一个任务在运行，其运行的越久，该任务的 vruntime 自然就会越大，而没有被运行的任务，vruntime 是不会变化的。\n\n那么，**在 CFS 算法调度的时候，会优先选择 vruntime 少的任务，以保证每个任务的公平性**。\n\n在计算虚拟运行时间 vruntime 还要考虑普通任务的**权重值**，注意权重值并不是优先级的值，内核中会有一个 `nice` 级别与权重值的转换表，nice 级别越低的权重值就越大。于是就有了以下这个公式：：\n```\nvruntime += 实际运行时间（delta_exec）* NICE_0_LOAD / 权重\n```\n先不用管 不用管 NICE_0_LOAD 是什么。那么在「同样的实际运行时间」里，高权重任务的 vruntime 比低权重任务的 vruntime 少，自然也就优先运行高权重的任务啦。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cvav6ge1bww0",
                            "created": 1693904917585,
                            "text": "CPU 运行队列",
                            "note": "实上，每个 CPU 都有自己的**运行队列（Run Queue, rq）**，用于描述在此 CPU 上所运行的所有进程，其队列包含三个运行队列，Deadline 运行队列 `dl_rq`、实时任务运行队列 `rt_rq` 和 CFS 运行队列 `cfs_rq`，其中 cfs_rq 是用红黑树来描述的，按 vruntime 大小来排序的，最左侧的叶子节点，就是下次会被调度的任务。\n\n![](https://camo.githubusercontent.com/7938371f0a1b3f8e3ed6a3e2056a57452349c632b77c83647d9b2b791ff19520/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f4350552545342542432541412545352538352542312545342542412541422f4350552545392539382539462545352538382539372e706e67)\n\n这几种调度类是有优先级的，优先级如下：`Deadline > Realtime > Fair`，这意味着 Linux 选择下一个任务执行的时候，会按照此优先级顺序进行选择，也就是说先从 dl_rq 里选择任务，然后从 rt_rq 里选择任务，最后从 cfs_rq 里选择任务。因此，**实时任务总是会比普通任务优先被执行**。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cvav8g94zd40",
                            "created": 1693905074017,
                            "text": "调整优先级",
                            "note": "启动任务的时候，没有特意去指定优先级的话，默认情况下都是普通任务，普通任务的调度类是 Fair，由 CFS 调度器来进行管理。CFS 调度器的目的是实现任务运行的公平性，也就是保障每个任务的运行的时间是差不多的。\n\n可以调整任务的 nice 值，从而让优先级高一些的任务执行更多时间。nice 的值能设置的范围是 `-20～19`， 值越低，表明优先级越高，因此 -20 是最高优先级，19 则是最低优先级，默认优先级是 `0`。\n\n事实上，nice 值并不是表示优先级，而是表示优先级的修正数值，它与优先级（priority）的关系是这样的：`priority(new) = priority(old) + nice`。\n\n内核中，priority 的范围是 `0~139`，值越低，优先级越高，其中前面的`0~99` 范围是提供给实时任务使用的，而 nice 值是映射到 `100~139`，这个范围是提供给普通任务用的，因此 nice 值调整的是普通任务的优先级。\n![](https://camo.githubusercontent.com/5007c66cf519560fe58e85929d8d3306df5537fe014d5a0a63ff6fb6961a9c00/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f4350552545342542432541412545352538352542312545342542412541422f2545342542432539382545352538352538382545372542412541372e706e67)\n\n可以在启动任务的时候，可以指定 nice 的值，比如将 mysqld 以 -3 优先级：\n```shell\nnice -n -3 /usr/sbin/mysqld\n```\n\n修改已经运行中的任务的优先级，则可以使用 renice 来调整 nice 值：\n```shell\nrenice -10 -p <进程pid>\n```\n\n变成实时任务：\n```shell\n# 修改调度策略为 SCHED_FIFO，并且优先级为 1\nchrt -f 1 -p <进程pid>\n```"
                        },
                        "children": []
                    }
                ]
            }
        ]
    },
    "template": "right",
    "theme": "classic",
    "version": "1.4.43"
}