{
    "root": {
        "data": {
            "id": "cvavsgf53340",
            "created": 1693906641663,
            "text": "浮点数"
        },
        "children": [
            {
                "data": {
                    "id": "cvavuz7mnts0",
                    "created": 1693906839296,
                    "text": "为什么负数要用补码表示",
                    "note": "对于 int 类型的数字 1 的二进制数表示如下：\n![](https://camo.githubusercontent.com/14dbd78487557ecebf9ad361f526801c51e54dc6d166e564c6f93a93b34f1eeb/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545362542352541452545372538322542392f696e74312e706e67)\n\n补码就是把正数的二进制全部取反再加 1：\n![](https://camo.githubusercontent.com/6357b346bd10fb89d26dcd62180c436920d65b7b11a9ae470d96454933c42d95/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545362542352541452545372538322542392f2545352538462538442545372541302538312e706e67)\n\n假设不用补码的方式来表示负数，而只是把最高位的符号标志位变为 1 表示负数：\n![](https://camo.githubusercontent.com/6d6219ba9dcc448a8bfb22c102372ec551c5dab11bb4694bc6c1d5bba64e5cfc/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545362542352541452545372538322542392f2545392539442539452545352538462538442545372541302538312545382542462539302545372541452539372e706e67)\n\n可以看到，如果负数不是使用补码的方式表示，则在做基本对加减法运算的时候，还需要多一步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法。\n\n加减法运算在计算机里是很常使用的，所以为了性能考虑，应该要尽量简化这个运算过程。\n\n而用了补码的表示方式，对于负数的加减法操作，实际上是和正数加减法操作一样的。\n![](https://camo.githubusercontent.com/2f40ae7e0c444e1ee994baf8430a0b73de202bfecc0f75f022c86bd9b2e28257/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545362542352541452545372538322542392f2545382541312541352545372541302538312545382542462539302545372541452539372545382542462538372545372541382538422e706e67)\n"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cvaw0a4ovjc0",
                    "created": 1693907254884,
                    "text": "十进制小数转二进制",
                    "note": "整数部分使用`除 2 取余法`，小数部分使用`乘 2 取整法`：\n![](https://camo.githubusercontent.com/f61aaae66f42918e224908be54f0fab872683319e0a4f068dbecb3e8f0b2e4f9/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545362542352541452545372538322542392f2545352538442538312545382542462539422545352538382542362545352542302538462545362539352542302545382542442541432545342542412538432545382542462539422545352538382542362e706e67)\n\n**但是，并不是所有小数都可以用二进制表示**，前面提到的 0.625 小数是一个特例，刚好通过乘 2 取整法的方式完整的转换成二进制。\n\n**由于计算机的资源是有限的，所以是没办法用二进制精确的表示 0.1，只能用「近似值」来表示，就是在有限的精度情况下，最大化接近 0.1 的二进制数，于是就会造成精度缺失的情况。**"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cvaw39g2mqw0",
                    "created": 1693907488488,
                    "text": "二进制小数转十进制",
                    "note": "小数点前面的指数幂是正数，小数点后面的指数幂是**负数**。\n![](https://camo.githubusercontent.com/ea9eb6231e6aacf86e63c82ccbc413a53c3743686c01984d5d91341d2bfcbe42/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545362542352541452545372538322542392f254535254230253846254536253935254230254538254244254143254534254241253843254538254246253942254535253838254236322e706e67)"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cvaw4dnlywg0",
                    "created": 1693907576015,
                    "text": "计算机是怎么存小数的",
                    "note": "计算机使用**科学记数法**来存储小数。\n\n如果二进制要用到科学记数法，同时要规范化，那么不仅要保证基数为 2，还要保证小数点左侧只有 1 位，而且必须为 1。\n\n所以通常将 `1000.101` 这种二进制数，规格化表示成 `1.000101 x 2^3`：\n\n- `000101` 称为**尾数**，即小数点后面的数字；\n- `3` 称为**指数**，指定了小数点在数据中的位置；\n\n![](https://camo.githubusercontent.com/92feb296fdfc73b7709ae8af9e2ade470c74442e80fefdd94a9f74d9fca96846/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545362542352541452545372538322542392f666c6f61742e706e67)\n\n- **符号位**：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；\n- **指数位**：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，**指数位的长度越长则数值的表达范围就越大**；\n- **尾数位**：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且**尾数的长度决定了这个数的精度**，因此如果要表示精度更高的小数，则就要提高尾数位的长度；\n\n![](https://camo.githubusercontent.com/f406c3e83f5e93e7ba12d265f22f30a839236753fca11ab876df29c7883f1aaf/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545362542352541452545372538322542392f666c6f61742545352541442539382545352538322541382e706e67)\nfloat 中的「指数位」就跟这里移动的位数有关系，把**移动的位数再加上「偏移量」**，float 的话偏移量是 127，相加后就是指数位的值了，即指数位这 8 位存的是 10000010（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。\n\n> 在算指数的时候，为什么要加上偏移量?\n\n因为指数是有符号的整数，而有符号整数的计算是比无符号整数麻烦的，所以为了减少不必要的麻烦，**在实际存储指数的时候，需要把指数转换成无符号整数**。而当我们需要计算实际的十进制数的时候，再把指数减去「偏移量」即可。\n\nfloat 的指数部分是 8 位，IEEE 标准规定单精度浮点的指数取值范围是 `-126 ~ +127`，于是为了把指数转换成无符号整数，就要加个偏移量，比如 float 的指数偏移量是 127，这样指数就不会出现负数了。\n\n在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：\n![](https://camo.githubusercontent.com/4a262521a677c7ab8088449777ab2342710b1fcfe4460420e3fae9eef8b8de02/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545362542352541452545372538322542392f666c6f61742545352538352541432545352542432538462e706e67)\n\n![](https://camo.githubusercontent.com/e4d5dde605bacaebfd2170befd82c28f415a890c445049d48effc3b2c1c14c02/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737433406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545362542352541452545372538322542392f666c6f61742545382542442541432545342542412538432545382542462539422545352538382542362545342542452538422545352541442539302e706e67)\n\n二进制只能精准表达 2 除尽的数字 1/2, 1/4, 1/8，但是对于 0.1(1/10) 和 0.2(1/5)，在二进制中都无法精准表示时，需要根据精度舍入。"
                },
                "children": []
            }
        ]
    },
    "template": "right",
    "theme": "classic",
    "version": "1.4.43"
}