{
    "root": {
        "data": {
            "id": "cvmuk1ahow80",
            "created": 1695121880187,
            "text": "互斥与同步"
        },
        "children": [
            {
                "data": {
                    "id": "cvmum9wtnio0",
                    "created": 1695122055680,
                    "text": "竞争与协作"
                },
                "children": [
                    {
                        "data": {
                            "id": "cvmuox8w45c0",
                            "created": 1695122263204,
                            "text": "互斥的概念",
                            "note": "由于多线程执行操作共享变量的这段代码可能会导致竞争状态，因此我们将此段代码称为`临界区（critical section）`，它是访问共享资源的代码片段，一定不能给多线程同时执行。\n\n`互斥（mutualexclusion）`，保证一个线程在临界区执行时，其他线程应该被阻止进入临界区。\n"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cvmuq3lou4g0",
                            "created": 1695122355403,
                            "text": "同步的概念",
                            "note": "`同步`，就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步。"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cvmuqr0fg4g0",
                    "created": 1695122406360,
                    "text": "互斥与同步的实现和使用",
                    "note": "为了实现进程/线程间正确的协作，操作系统必须提供实现进程协作的措施和方法，主要的方法有两种：\n\n- 锁：加锁、解锁操作；\n- 信号量：P、V 操作；\n\n这两个都可以方便地实现进程/线程互斥，而信号量比锁的功能更强一些，它还可以方便地实现进程/线程同步。\n\n下文的实现都是简单的演示。"
                },
                "children": [
                    {
                        "data": {
                            "id": "cvmurg3zzs00",
                            "created": 1695122460995,
                            "text": "锁",
                            "note": "使用加锁操作和解锁操作可以解决并发线程/进程的互斥问题。\n\n任何想进入临界区的线程，必须先执行加锁操作。若加锁操作顺利通过，则线程可进入临界区；在完成对临界资源的访问后再执行解锁操作，以释放该临界资源。\n\n根据锁的实现不同，可以分为「忙等待锁」和「无忙等待锁」。\n",
                            "expandState": "expand"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cvmushv1bmg0",
                                    "created": 1695122543171,
                                    "text": "测试和置位指令",
                                    "note": "在说明「忙等待锁」的实现之前，先介绍现代 CPU 体系结构提供的特殊**原子操作指令** —— `测试和置位（Test-and-Set）指令`。\n\n用 C 代码表示 Test-and-Set 指令的形式如下：\n![](https://camo.githubusercontent.com/78721952b97c51c1856c8f94c7321df9e54e3d37c5b9dd33be7da0c01ece0526/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545342542412539322545362539362541352545342542382538452545352539302538432545362541442541352f31332d54657374416e645365742e6a7067)\n\n- 把 old_ptr 更新为 new 的新值\n- 返回 old_ptr 的旧值；\n\n关键是这些代码是**原子执行**。因为既可以测试旧值，又可以设置新值，所以我们把这条指令叫作「测试并设置」。\n\n**原子操作就是要么全部执行，要么都不执行，不能出现执行到一半的中间状态**。\n"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cvmuvg5vmu00",
                                    "created": 1695122774566,
                                    "text": "忙等待锁（自旋锁）",
                                    "note": "用 Test-and-Set 指令实现的忙等待锁：\n![](https://camo.githubusercontent.com/f161e1132b0bcd549c8a4ec13679da3c157283747b02645969c2c154e516ce4b/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545342542412539322545362539362541352545342542382538452545352539302538432545362541442541352f31342d2545382538372541412545362539372538422545392539342538312e6a7067)\n\n当某一个线程已经持有锁（即 flag 为 1）。本线程调用 `lock()`，然后调用 `TestAndSet(flag, 1)`，只要另一个线程一直持有锁，TestAndSet() 会重复返回 1，本线程会一直忙等。当 flag 终于被改为 0，本线程会调用 TestAndSet()，返回 0 并且原子地设置为 1，从而获得锁，进入临界区。\n\n当获取不到锁时，线程就会一直 while 循环，不做任何事情，所以就被称为「忙等待锁」，也被称为`自旋锁（spin lock）`。\n\n在单处理器上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。\n"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cvmuygxw8yo0",
                                    "created": 1695123011352,
                                    "text": "无等待锁",
                                    "note": "不自旋，当没获取到锁的时候，就把当前线程放入到锁的等待队列，然后执行调度程序，把 CPU 让给其他线程执行。\n\n![](https://camo.githubusercontent.com/3a4e9f191f9b5d7ab2943d26e2a81dc1c87545d2043089b78f0e7b7f1d94f338/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545342542412539322545362539362541352545342542382538452545352539302538432545362541442541352f31352d2545362539372541302545372541442538392545352542452538352545392539342538312e6a7067)\n\n推荐：《操作系统导论》第 28 章锁。"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "cvmv0pib0ts0",
                            "created": 1695123186729,
                            "text": "信号量",
                            "note": "原理就是 P、V 操作，可以参考前文 《进程间的通信方式》。\n\n信号量数据结构与 PV 操作的算法描述如下图：\n![](https://camo.githubusercontent.com/df37f40a14d243a512fd704e16e1c4f6e4eed1c8217eb42fa6715b4d3376f561/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545342542412539322545362539362541352545342542382538452545352539302538432545362541442541352f31372d25453625393325384425453425424425394325453725423325424225453725424225394650562545372541452539372545362542332539352545362538462538462545382542462542302e6a7067)\n\nPV 操作的函数是由操作系统管理和实现的，所以操作系统已经使得执行 PV 函数时是具有原子性的。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cvmv81tf40w0",
                            "created": 1695123762071,
                            "text": "生产者 - 消费者问题",
                            "note": "生产者 - 消费者问题描述：\n\n- 生产者在生成数据后，放在一个缓冲区中；\n- 消费者从缓冲区取出数据处理；\n- 任何时刻，只能有一个生产者或消费者可以访问缓冲区；\n\n需要三个信号量，分别是：\n\n- 互斥信号量 mutex：用于互斥访问缓冲区，初始化值为 1；\n- 资源信号量 fullBuffers：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）；\n- 资源信号量 emptyBuffers：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n（缓冲区大小）；\n"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cvmvbhd4fco0",
                    "created": 1695124031007,
                    "text": "经典同步问题"
                },
                "children": [
                    {
                        "data": {
                            "id": "cvmveykqpq80",
                            "created": 1695124303566,
                            "text": "哲学家就餐",
                            "note": "问题描述：\n\n- 5 个老大哥哲学家，闲着没事做，围绕着一张圆桌吃面；\n- 巧就巧在，这个桌子只有 5 支叉子，每两个哲学家之间放一支叉子；\n- 哲学家围在一起先思考，思考中途饿了就会想进餐；\n- 奇葩的是，这些哲学家要两支叉子才愿意吃面，也就是需要拿到左右两边的叉子才进餐；\n- 吃完后，会把两支叉子放回原处，继续思考；\n\n如何保证哲 学家们的动作有序进行，而不会出现有人永远拿不到叉子呢？"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cvmvfesw57k0",
                                    "created": 1695124338887,
                                    "text": "方案一",
                                    "note": "![](https://camo.githubusercontent.com/b86f4702522c34278e69d3448d1338e1089cfe41b867477a3b3a5314a477961a/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545342542412539322545362539362541352545342542382538452545352539302538432545362541442541352f32342d2545352539332542322545352541442541362545352541452542362545382542462539422545392541342539302d2545362539362542392545362541312538382545342542382538302545372541342542412545342542452538422e6a7067)\n\n这种解法存在一个极端的问题：假设五位哲学家**同时拿起左边的叉子**，桌面上就没有叉子了， 这样就没有人能够拿到他们右边的叉子，也就说每一位哲学家都会在 `P(fork[(i + 1) % N ])` 这条语句阻塞了，很明显这发生了**死锁**的现象。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cvmvgnmduw80",
                                    "created": 1695124436449,
                                    "text": "方案二",
                                    "note": "既然「方案一」会发生同时竞争左边叉子导致死锁的现象，那么我们就在拿叉子前，加个互斥信号量，代码如下：\n\n![](https://camo.githubusercontent.com/fb013e6aa37f337601003eaf0e08a41870f3d9e6a560fec91eb717261c46f451/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545342542412539322545362539362541352545342542382538452545352539302538432545362541442541352f32362d2545352539332542322545352541442541362545352541452542362545382542462539422545392541342539302d2545362539362542392545362541312538382545342542412538432545372541342542412545342542452538422e6a7067)\n\n方案二虽然能让哲学家们按顺序吃饭，但是每次进餐只能有一位哲学家，而桌面上是有 5 把叉子，按道理是能可以有两个哲学家同时进餐的，所以从**效率**角度上，这不是最好的解决方案。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cvmvho3ao2w0",
                                    "created": 1695124515835,
                                    "text": "方案三",
                                    "note": "避免哲学家可以同时拿左边的刀叉，采用分支结构，根据哲学家的编号的不同，而采取不同的动作。\n\n即让偶数编号的哲学家「先拿左边的叉子后拿右边的叉子」，奇数编号的哲学家「先拿右边的叉子后拿左边的叉子」。\n\n![](https://camo.githubusercontent.com/5d2b41e8298270a67385356919abcbb2537ae0a9f50c83957e29f28f544df833/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545342542412539322545362539362541352545342542382538452545352539302538432545362541442541352f32382d2545352539332542322545352541442541362545352541452542362545382542462539422545392541342539302d2545362539362542392545362541312538382545342542382538392545372541342542412545342542452538422e6a7067)\n\nV 操作是不需要分支的，因为 V 操作是不会阻塞的。\n\n![](https://camo.githubusercontent.com/9da461debe81aa1971660f2f8cbb8f47886e4fccd372e990e953a65e25b29091/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545342542412539322545362539362541352545342542382538452545352539302538432545362541442541352f32392d2545352539332542322545352541442541362545352541452542362545382542462539422545392541342539302d2545362539362542392545362541312538382545342542382538392d2545352539422542452545382541372541332e6a7067)\n方案三既不会出现死锁，也可以两人同时进餐。\n"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cvmvj69ooig0",
                                    "created": 1695124633768,
                                    "text": "方案四",
                                    "note": "另外一种可行的解决方案，我们用一个数组 state 来记录每一位哲学家的三个状态，分别是在进餐状态、思考状态、饥饿状态（正在试图拿叉子）。\n\n那么，一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态。\n\n![](https://camo.githubusercontent.com/f81b41c3c644cf1151660e7a600b180dcc515889a697190c7a41fc63186034d2/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545342542412539322545362539362541352545342542382538452545352539302538432545362541442541352f33302d2545352539332542322545352541442541362545352541452542362545382542462539422545392541342539302d2545362539362542392545362541312538382545352539422539422545372541342542412545342542452538422e6a7067)\n\n![](https://camo.githubusercontent.com/4dbc34798df8b6b62ea990c0da204a11f447b594a225f03083dc746e3b2cac19/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545342542412539322545362539362541352545342542382538452545352539302538432545362541442541352f33312d2545352539332542322545352541442541362545352541452542362545382542462539422545392541342539302d2545362539362542392545362541312538382545352539422539422d2545352539422542452545382541372541332e6a7067)\n\n方案四同样不会出现死锁，也可以两人同时进餐。\n"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "cvmvns6685s0",
                            "created": 1695124994901,
                            "text": "读者 - 写者问题",
                            "note": "问题描述：\n\n- 「读 - 读」允许：同一时刻，允许多个读者同时读\n- 「读 - 写」互斥：没有写者时读者才能读，没有读者时写者才能写\n- 「写 - 写」互斥：没有其他写者时，写者才能写\n"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cvmvqc43v6o0",
                                    "created": 1695125195041,
                                    "text": "方案一",
                                    "note": "读者优先策略：\n\n- 只要有读者正在读的状态，后来的读者都可以直接进入，\n- 如果读者持续不断进入，则写者会处于饥饿状态。\n\n![](https://camo.githubusercontent.com/bc61cf142e3e5b3f69793470209fb574093ea47d3b7b6e6f1e3393f1e58d704d/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545342542412539322545362539362541352545342542382538452545352539302538432545362541442541352f33322d2545382541462542422545382538302538352545352538362539392545382538302538352d2545362539362542392545362541312538382545342542382538302545372541342542412545342542452538422e6a7067)"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cvmvqywrwi80",
                                    "created": 1695125244663,
                                    "text": "方案二",
                                    "note": "写者优先策略：\n\n- 只要有写者准备要写入，写者应尽快执行写操作，后来的读者就必须阻塞；\n- 如果有写者持续不断写入，则读者就处于饥饿状态；\n\n![](https://camo.githubusercontent.com/31e1c83a28a5bf60d716841845597398c708d5bc7a53547a3b58aa7c8c1e6bf0/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545342542412539322545362539362541352545342542382538452545352539302538432545362541442541352f33332d2545382541462542422545382538302538352545352538362539392545382538302538352d2545362539362542392545362541312538382545342542412538432545372541342542412545342542452538422e6a7067)\n\n注意，这里 `rMutex` 的作用，开始有多个读者读数据，它们全部进入读者队列，此时来了一个写者，执行了 `P(rMutex)` 之后，后续的读者由于阻塞在 rMutex 上，都不能再进入读者队列，而写者到来，则可以全部进入写者队列，因此保证了写者优先。\n\n同时，第一个写者执行了 `P(rMutex)` 之后，也不能马上开始写，必须等到所有进入读者队列的读者都执行完读操作，通过 `V(wDataMutex)` 唤醒写者的写操作。\n"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cvmvwxhi2yo0",
                                    "created": 1695125711748,
                                    "text": "方案三",
                                    "note": "公平策略：\n\n- 优先级相同；\n- 写者、读者互斥访问；\n- 只能一个写者访问临界区；\n- 可以有多个读者同时访问临界资源；\n\n![](https://camo.githubusercontent.com/555e1ab465dde06e291a6ae1c3a74fe4a6d4218461aaca43a2db9c0cb797f6af/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f73742f2545362539332538442545342542442539432545372542332542422545372542422539462f2545342542412539322545362539362541352545342542382538452545352539302538432545362541442541352f33342d2545382541462542422545382538302538352545352538362539392545382538302538352d2545362539362542392545362541312538382545342542382538392545372541342542412545342542452538422e6a7067)\n\n开始来了一些读者读数据，它们全部进入读者队列，此时来了一个写者，执行 `P(flag)` 操作，使得后续到来的读者都阻塞在 flag 上，不能进入读者队列，这会使得读者队列逐渐为空，即 `rCount` 减为 0。\n\n这个写者也不能立马开始写（因为此时读者队列不为空），会阻塞在信号量 `wDataMutex` 上，读者队列中的读者全部读取结束后，最后一个读者进程执行 `V(wDataMutex)`，唤醒刚才的写者，写者则继续开始进行写操作。\n"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "template": "right",
    "theme": "classic",
    "version": "1.4.43"
}