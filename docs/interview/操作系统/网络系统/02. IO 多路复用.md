
[TOC]
# I/O 多路复用

## I/O 多路复用

经典的 C10K 问题 ，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。

如果采用多进程/多线程模型，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统是扛不住的。

一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。

 `I/O 多路复用技术`，它允许应用程序同时监视多个文件描述符（通常是套接字），并在有数据可读或可写时进行相应的操作。
 
 select/poll/epoll 在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。
 
下面通过网络来举例说明 这三种 多路复用的实现方式。
## select/poll

`select` 实现多路复用的方式是，将已连接的 socket 都放到一个**文件描述符集合**，然后调用 select 函数将文件描述符集合**拷贝到内核**里，让内核检查是否有网络事件产生，检查方式就是通过**遍历**文件描述符集合，当检查到有事件产生后，将此 socket 标记为可读/可写，接着再把整个文件描述符集合**拷贝回用户态**，然后用户态还需要**遍历**找到可读/可写的 socket，然后再对其处理。

所以，对于 select 这种方式，**需要进行 2 次「遍历」文件描述符集合，而且还会发生 2 次「拷贝」文件描述符集合**。

select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 `FD_SETSIZE` 限制， 默认最大值为 1024，只能监听 `0~1023` 的文件描述符。

`poll` 不再用 BitsMap 来存储所关注的文件描述符，取而代之用**动态数组**，以**链表**形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。

但是 poll 和 select 并没有太大的本质区别，**都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合**，这种方式随着并发数上来，性能的损耗会呈指数级增长。
## epoll

[epoll 使用详解](https://www.cnblogs.com/xuewangkai/p/11158576.html)

epoll 的用法。先用e poll_create 创建一个 epol l对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll_wait 等待数据。

```c
int s = socket(AF_INET, SOCK_STREAM, 0);
bind(s, ...);
listen(s, ...)

int epfd = epoll_create(...);
epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中

while(1) {
    int n = epoll_wait(...);
    for(接收到数据的socket){
        //处理
    }
}
```

epoll 通过两个方面，很好解决了 select/poll 的问题：

- 使用**红黑树跟踪进程所有待检测的文件描述符**，把需要监控的 socket 通过 `epoll_ctl()` 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 `O(logn)`。
- 采用**事件驱动**的机制通知，内核里维护了一个**链表来记录就绪事件**，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 `epoll_wait()` 函数时，**只会返回有事件发生的文件描述符的个数**，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。

![](https://camo.githubusercontent.com/1c17526ad053cc12e0ae3e0f293e1bb57487e8852d3c1cdd8995694d4dafcd60/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545362539332538442545342542442539432545372542332542422545372542422539462f2545352541342539412545382542372541462545352541342538442545372539342541382f65706f6c6c2e706e67)

epoll 的方式**即使监听的 Socket 数量越多的时候，效率不会大幅度降低**，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，epoll 被称为解决 C10K 问题的利器。
### 触发模式

epoll 支持两种事件触发模式：

- **边缘触发（edge-triggered，ET）**，当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；
- **水平触发（level-triggered，LT）**，当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，目的是告诉我们有数据需要读取。

如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。

如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会**循环**从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，**边缘触发模式一般和非阻塞 I/O 搭配使用**，程序会一直执行 I/O 操作，直到系统调用（如 read 和 write）返回错误，错误类型为 `EAGAIN` 或 `EWOULDBLOCK`。

select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。

另外，使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用。因为**多路复用 API 返回的事件并不一定可读写的**，如果使用阻塞 I/O， 那么在调用 read/write 时则会发生程序阻塞，因此最好搭配非阻塞 I/O，以便应对极少数的特殊情况。

