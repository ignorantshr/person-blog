
[TOC]
# 内存页面置换算法

## 缺页中断

当 CPU 访问的页面不在物理内存时，便会产生一个`缺页中断`(缺页异常)，请求操作系统将所缺页调入到物理内存。那它与一般中断的主要区别在于：

- 缺页中断在**指令执行期间**产生和处理中断信号，而一般中断在一条**指令执行完成后**检查和处理中断信号。
- 缺页中断**返回到该指令**的开始重新执行该指令，而一般中断**返回到该指令的下一个指令**执行。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E6%B5%81%E7%A8%8B.png)

1. 在CPU里访问一条 load m 指令，然后CPU回去找 m 对应的页表项；
1. 如果该页表项的状态位是**有效**，那么CPU可以直接访问物理内存，如果状态位是**无效**，则CPU会发送缺页中断请求；
1. 操作系统接收到了缺页中断请求，执行缺页中断处理函数，先查找该页面在磁盘中的页面的位置；
1. 找到磁盘中对应的页面之后，需要把该页面换入到物理内存中，换如之前需要在物理内存中找空闲页，找到了空闲页才能换入；
1. 页面从磁盘换入到物理内存之后，把页表项中的状态位修改为**有效**；
1. 最后，CPU重新执行导致缺页异常的指令。

在物理内存找不到空闲页的话，就说明此时内存已满了，这时候，就需要`页面置换算法`选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。

页表项通常有如下图的字段：
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E9%A1%B5%E8%A1%A8%E9%A1%B9%E5%AD%97%E6%AE%B5.png)

- *状态位*，表示该页是否有效，即是否在物理内存中，供程序访问时参考
- *访问字段*，记录该页在一段时间内被访问的次数，供页面置换算法选择出页时参考
- *修改位*，表示该页在调入内存后是否有被修改过。由于内存中的每一页都在磁盘上保留一份副本，因此，如果没有修改，置换该页时就不需要写回到磁盘；否则将该页写回到磁盘，更新磁盘中保留的副本
- *硬盘地址*，指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用

虚拟内存映射到物理内存流程：
![](https://camo.githubusercontent.com/067527081cde134feb7084a0f6484a5372b23669fe3b68c6c7cd869f8f2ceafa/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545382542302538332545352542412541362545372541452539372545362542332539352f2545382539392539412545362538422539462545352538362538352545352541442539382545372541452541312545372539302538362545362542352538312545372541382538422e706e67)
## 最佳页面置换算法（OPT）

置换在未来最长时间不会被访问的页面。

该算法实现需要计算内存中每个逻辑页面的「下一次」访问时间，然后比较，选择时间最长的那个页面，将其置换掉。

![](https://camo.githubusercontent.com/4f5e5bc2f5e86ed350c72ad756f7e4699e5a104fba3cb39e52284cdb77653586/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545382542302538332545352542412541362545372541452539372545362542332539352f2545362539432538302545342542432539382545372542442541452545362538442541322545372541452539372545362542332539352e706e67)

该算法非常理想，但是实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。

所以，最佳页面置换算法**作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的**。

## 先进先出置换算法（FIFO）

选择在内存驻留时间很长的页面中置换。

![](https://camo.githubusercontent.com/12c1e809ab7f3cb1cad4f2678bb8df4f05be187185bad1e77a5b50aa2bd593ee/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545382542302538332545352542412541362545372541452539372545362542332539352f4649464f2545372542442541452545362538442541322545372541452539372545362542332539352e706e67)

跟最佳页面置换算法比较起来，性能明显差了很多。

## 最近最久未使用的置换算法（LRU）

选择最长时间没有被访问的页面进行置换。

![](https://camo.githubusercontent.com/bb58a8dc369912a76fff8e45bb93e4a5f82d27eb600d4deb016045aa09d4ff94/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545382542302538332545352542412541362545372541452539372545362542332539352f4c52552545372542442541452545362538442541322545372541452539372545362542332539352e706e67)

虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。

困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。

所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。

## 时钟页面置换算法（Lock）

时钟页面置换算法跟 LRU 近似，（Clock Page Replacement Algorithm），也称为最近未使用（NRU）算法，又是对 FIFO 的一种改进。

该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。

当发生缺页中断时，算法首先检查表针指向的页面：

- 如果它的访问位（也称为引用位）是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；
- 如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；

![](https://camo.githubusercontent.com/adccaa72e9e2a1b1615b552df38fa5f576da36fc2badcbc0830a69cd74c35d40/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7869616f6c696e636f6465722f496d616765486f7374322f2545362539332538442545342542442539432545372542332542422545372542422539462f2545382542302538332545352542412541362545372541452539372545362542332539352f2545362539372542362545392539322539462545372542442541452545362538442541322545372541452539372545362542332539352e706e67)

时钟页面置换算法简单且高效，它解决了"FIFO"（先进先出）页面置换算法导致的不公平问题，因为它考虑了页面是否被访问过的情况。

## 最不常用置换算法（LFU）

选择「访问次数」最少的那个页面，并将其淘汰。

它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。

要增加一个计数器来实现，硬件成本是比较高，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。

还有个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。

这个问题的解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。

