{
    "root": {
        "data": {
            "id": "cv0fwi37eag0",
            "created": 1692846221426,
            "text": "事务"
        },
        "children": [
            {
                "data": {
                    "id": "cv0fwohjjg00",
                    "created": 1692846235354,
                    "text": "事务的特性",
                    "note": "MyISAM 引擎就不支持事务。\n\n事务（Transaction）的四个特性：\n\n- **原子性（Atomicity）**：一个事务中的操作，要么全部完成，要么全部不完成。如果事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像从未发生过一样。\n- **一致性（Consistency）**：指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。\n- **隔离性（Isolation）**：允许多个并发事务同时对数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致的数据不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。\n- **持久性（Durability）**：事务处理结束后，对数据的修改是持久化的，不是临时的，即使系统故障也不会丢失。\n\nInnoDB 引擎通过什么技术来保证事务的这四个特性：\n\n- 原子性是通过 undo log（回滚日志） 来保证的\n- 持久性是通过 redo log （重做日志）来保证的\n- 隔离性是通过 MVCC （多版本并发控制）来保证的\n- 一致性是通过 原子性+持久性+隔离性 保证的"
                },
                "children": [
                    {
                        "data": {
                            "id": "cv0gcp72hlk0",
                            "created": 1692847490724,
                            "text": "事务的隔离性"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cv0gd0uen0o0",
                                    "created": 1692847516080,
                                    "text": "并行事务会引发什么问题",
                                    "note": "同时处理多个事务的时候，就可能出现以下现象，按照严重性从高到低排序：\n\n- 脏读（dirty read）\n- 不可重复读（non-repeatable read）\n- 幻读（phantom read）"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cv0gd1p7y6g0",
                                            "created": 1692847517943,
                                            "text": "脏读",
                                            "note": "一个事务读取到了另一个事务的修改后还未提交的数据，就发生了脏读。\n\n因为事务是还没提交事务的，也就是它随时可能发生回滚操作，可能会导致其他事务读取到了过期的数据。\n\n![](https://camo.githubusercontent.com/2992fea82565bb347303c5cf197b72f4fac8c6815c8598c1d2e175533092d875/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f31306235313330303865613335656538383063353932613838616463623132662e706e67)"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cv0gfs74eko0",
                                            "created": 1692847732350,
                                            "text": "不可重复读",
                                            "note": "在一个事务内多次读取同一个数据，如果前后数据不一致，就发生了不可重复读。\n\n在一个事务内两次读取过程中，如果发生了其他事务修改并提交了这个数据，就会导致不可重复读发生。\n\n![](https://camo.githubusercontent.com/ceea7e9e953b031a8698bfd84a562fbb49e6483a30419a3093175460246183c3/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f66356234663866306330616463663034346233346331663330306139356162662e706e67)"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cv0gig78xxc0",
                                            "created": 1692847941329,
                                            "text": "幻读",
                                            "note": "在一个事务内多次查询符合某个条件的【记录数量】，如果出现前后记录数量不一致的情况，就是发生了幻读。\n\n因为其他事务可能会修改符合查询条件的数据。\n\n![](https://camo.githubusercontent.com/a7cbc84fbf43d09cb9401693fcb9825f53f7ea02452c6ad4b51aa7cde467552b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f64313961313031396463333564666538636665376662666638636439376533312e706e67)\n"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cv0gkpo5hls0",
                                    "created": 1692848118670,
                                    "text": "事务的隔离级别",
                                    "note": "SQL 标准提出了四种隔离级别来规避上述这些现象，隔离级别越高，性能效率就越低：\n\n- **读未提交（read uncommitted）**：一个事务还没提交，它的变更就能被其它事务看到。可能出现：\n\t- 脏读\n    - 不可重复读\n    - 幻读\n- **读提交（read committed）**：一个事务提交之后，它的变更才能被其它事务看到。可能出现：\n\t- 不可重复读\n    - 幻读\n- **可重复读（repeatable read）**：一个事务中执行过程中，和该事务启动时看到的数据是一致的。**InnoDB 的默认隔离级别**。可能出现：\n\t- 幻读\n- **串行化（serializable）**：会对记录加上读写锁，多个事务同时对这条记录进行读写时，发生了冲突之后，其它事务必须等当前事务执行完毕才能继续执行\n\n不同的数据库厂商对 SQL 标准中规定的 4 种隔离级别的支持不一样，有的数据库只实现了其中几种隔离级别， **MySQL 虽然支持 4 种隔离级别，但是与 SQL 标准中规定的各级隔离级别允许发生的现象却有些出入**。\n\nMySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它**很大程度上避免幻读现象，并不是完全解决了**，详见[此文](https://xiaolincoding.com/mysql/transaction/phantom.html)，解决的方案有两种：\n\n- 针对**快照读**（普通select 语句），是通过 **MVCC 方式**解决的。因为在此隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据一致，即使中途有其它事务插入了一条数据，也查询不出来，所以就能避免幻读。\n- 针对**当前读**（select … for update 等语句），是通过 **next-key lock（记录锁+间隙锁）**解决的。因为在执行这种语句时会加上 `next-key lock`，如果有其它事务在这个锁的范围内插入了一条记录，那么这个插入语句就会被阻塞，所以就避免了幻读。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cv0jurwkht40",
                                    "created": 1692857370504,
                                    "text": "四种隔离级别如何实现",
                                    "note": "- 对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；\n- 对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；\n- 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过**Read View来实现的，它们的区别在于创建的 Read View 的时机不同。「读提交」是在*每个语句执行前*都会创建一个 Read View ，而「可重复读」是在*启动事务时*生成一个 Read View，然后整个事务期间都用这个  Read View**。\n\n注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，这两种开启事务的命令，事务的启动时机是不同的：\n\n- 执行了 `begin/start transaction` 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；\n- 执行了 `start transaction with consistent snapshot` 命令，就会马上启动事务。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cv0k3eb7fyo0",
                                    "created": 1692858046192,
                                    "text": "Read View 在 MVCC 里如何工作",
                                    "note": null
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cv0k3yfe4nc0",
                                            "created": 1692858089981,
                                            "text": "Read View 中的字段",
                                            "note": "![](https://camo.githubusercontent.com/3c3c7cef966d1495e734abc889e2261f64cde703747e67a39c94f4130cb27d5b/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f6d7973716c2f2545342542412538422545352538412541312545392539412539342545372541362542422f72656164766965772545372542422539332545362539452538342e64726177696f2e706e67)\n\n- `creator_trx_id`: 创建该 Read View 的事务的事务ID\n- `m_ids`: 创建 Read View 时，当前数据库中**活跃事务**的事务ID列表，**活跃事务是指启动了但未提交的事务**\n- `min_trx_id`: 创建 Read View 时，活跃事务列表中事务ID最小的事务ID，即`m_ids`的最小值\n- `max_trx_id`: 创建 Read View 时，**当前数据库应该分配给下一个事务的ID**，即全局事务中最大的事务ID值+1"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cv0l12nz9ps0",
                                            "created": 1692860685224,
                                            "text": "聚簇索引记录中的两个隐藏列",
                                            "note": "![](https://camo.githubusercontent.com/c591fde3a00f24aa4ef4f7c96e922c0f38a56e76afbf06da013649e79152bfa2/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f66353935643133343530383738616364303461666661383237333166373663352e706e67)\n\n对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：\n\n- trx_id：当一个事务对某条聚簇索引记录改动时，就会把**该事务ID记录在这里**\n- roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个**隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录**。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cv0l70vpom80",
                                            "created": 1692861151523,
                                            "text": "MVCC",
                                            "note": "**通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）**。\n\n在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：\n\n![](https://camo.githubusercontent.com/7ff8337ba9abd8a73577ce8f02856b235ef9bb6311485b197ecd4533dbad067d/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f6d7973716c2f2545342542412538422545352538412541312545392539412539342545372541362542422f52656164566965772e64726177696f2e706e67)\n\n一个事务去访问记录时，除了自己的更新记录总是可见外，还有以下几种情况，若记录的 `trx_id` 值：\n\n- 【小于】 Read View 中的  `min_trx_id` ，表示这个版本的记录是在创建 read view 之前已提交的事务生成的，所以该版本的记录对当前事务**可见**。\n- 【大于等于】 Read View 中的  `max_trx_id` ，表示这个版本的记录是在创建 read view 之后才启动的事务提交的，所以该版本记录对当前事务**不可见**。\n- 在 `min_trx_id` 和 `max_trx_id` 之间\n  - 【在】`m_ids` 列表中，表示生成该版本记录的是活跃事务，所以该版本记录对当前事务**不可见**。\n  - 【不在】`m_ids` 列表中，表示生成该版本记录的活跃事务已被提交，所以该版本记录对当前事务**可见**。\n\n```go\nfunc visiable() bool {\n  // 判断顺序不可颠倒\n  \n  if trx_id < min_trx_id {\n\treturn true\n  }\n  if trx_id >= max_trx_id {\n\treturn fasle\n  }\n  if trx_id in m_ids {\n\treturn fasle\n  }\n  if trx_id not in m_ids {\n\treturn true\n  }\n}\n```"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cv0let6h9xs0",
                                    "created": 1692861761674,
                                    "text": "可重复读如何工作",
                                    "note": "**可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View**。\n\n假设事务 A（事务 id 为 51）启动后，紧接着事务 B（事务 id 为 52）也启动了，那这两个事务创建的 Read View 如下：\n![](https://camo.githubusercontent.com/4ec2e17d4638a48d957c8e25d3379aae0f317d36e43c786ff32c2f1742d98549/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f6d7973716c2f2545342542412538422545352538412541312545392539412539342545372541362542422f25453425424125384225453525384125413161622545372539412538342545382541372538362545352539422542452d6e65772e706e67)\n\n接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：\n\n1. 事务 B 读取小林的账户余额记录，读到余额是 100 万；\n\n事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着**修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的**，也就是事务 B 可以获取到这条记录。\n\n2. 事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；\n\n这时 MySQL 会记录相应的** undo log，并以链表的方式串联起来，形成版本链**，如下图：\n\n![](https://camo.githubusercontent.com/4b0771c76633e830c7d2df9a6cd84d3786140553fef6bbca10cc8168f0896b81/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f6d7973716c2f2545342542412538422545352538412541312545392539412539342545372541362542422f2545342542412538422545352538412541316162254537253941253834254538254137253836254535253942254245322e706e67)\n\n3. 事务 B 读取小林的账户余额记录，读到余额还是 100 万；\n\n此时B去读余额记录，发现 trx_id 为 51，但是 51 在自己的 read view 中的 m_ids 中，说明是还未提交的活跃事务的修改，所以不可见。这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 可见的第一条记录（**trx_id「小于」事务 B 的 Read View 中的 min_trx_id 值，或者 trx_id 在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，但是不在 m_ids 范围内**），读取出 trx_id 为 50 的记录的余额。\n\n4. 事务 A 提交事务；\n\n5. 事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；\n\n此时B去读余额记录，发现 trx_id 为 51，但还是在启动事务时创建的 Read View 中的 m_ids 中，认为是还未提交的活跃事务的修改，所以不可见。接着通过版本链找到第一个可见版本，读取出 trx_id 为 50 的记录的余额。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cv0lz6upj800",
                                    "created": 1692863358720,
                                    "text": "读提交如何工作",
                                    "note": "**读提交隔离级别是在每个语句执行前，都会生成一个新的 Read View**。\n\n还是上一小节的例子，前几步都大同小异，重点说下最后一步。\n\n在事务 A 提交后，由于隔离级别是「读提交」，所以事务 B 在读数据的时候，会重新创建 Read View，此时事务 B 第三次读取数据时创建的 Read View 如下：\n![](https://camo.githubusercontent.com/901a96ccbeec6641ac844ae05752d37bd31c2874a4ab5cee7c2858731ef55990/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f6d7973716c2f2545342542412538422545352538412541312545392539412539342545372541362542422f254538254146254242254536253846253930254534254241254134254534254241253842254535253841254131322e64726177696f2e706e67)\n\n事务 B 在找到这条记录时，会发现**这条记录的 trx_id 是 51，比事务 B 的 Read View 中的 min_trx_id 值（52）还小，这意味着修改这条记录的事务早就在创建 Read View 前提交过了**，所以该版本的记录对事务 B 是可见的。\n"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "template": "right",
    "theme": "classic",
    "version": "1.4.43"
}