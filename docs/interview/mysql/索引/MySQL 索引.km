{
    "root": {
        "data": {
            "id": "cuy2eew57q80",
            "created": 1692605009572,
            "text": "MySQL 索引",
            "hyperlink": "https://github.com/xiaolincoder/CS-Base/blob/main/mysql/index/index_interview.md",
            "hyperlinkTitle": ""
        },
        "children": [
            {
                "data": {
                    "id": "cuy2fwzjf1c0",
                    "created": 1692605127324,
                    "text": "索引的分类",
                    "note": "可以按照四个角度来分类索引：\n\n- 数据结构： B+ 树索引、Hash 索引、Full-text 索引\n- 物理存储：聚簇索引（主键索引）、二级索引（辅助索引）\n- 字段特性：主键索引、唯一索引、普通索引、前缀索引\n- 字段个数：单列索引、联合索引",
                    "expandState": "expand"
                },
                "children": [
                    {
                        "data": {
                            "id": "cuy2fxb55og0",
                            "created": 1692605128025,
                            "text": "按数据结构分类",
                            "note": "B+ 树索引、Hash 索引、Full-text 索引。\n\n每一种存储引擎支持的索引类型不一定相同，例如 InnoDB 就不支持 hash 索引（但在内存结构中有一个自适应的 hash 索引）。\n\n在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：\n\n- 如果有主键，默认使用主键作为聚簇索引的索引键（key）\n- 如果没有主键，使用第一个不包含NULL值的唯一列作为聚簇索引的索引键（key）\n- 在以上两个条件都不满足的话，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）\n\n其它索引都属于辅助索引，也叫 二级索引或非聚簇索引。**创建的主键索引和二级索引默认使用的是 B+ 树索引**。\n\n![](https://cdn.xiaolincoding.com//mysql/other/dd076212a7637b9032c97a615c39dcd7.png)"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cuy3jzoysu00",
                                    "created": 1692608267781,
                                    "text": "B+ 树索引的存储和查询",
                                    "note": " B+ 树是多叉树，叶子节点存放数据，非叶子节点存放索引，而且每个节点里的数据是**按主键顺序存放的**。\n 每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中包含了所有索引值信息。\n 并且每一个叶子节点都指向下一个叶子节点，形成一个链表结构。\n \n下面举例说明 B+ 树索引的存储和查询方式：\n```SQL\nCREATE TABLE `product`  (\n  `id` int(11) NOT NULL,\n  `product_no` varchar(20)  DEFAULT NULL,\n  `name` varchar(255) DEFAULT NULL,\n  `price` decimal(10, 2) DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n```\n\n ![](https://camo.githubusercontent.com/7ef22bfb3c1a52d0e3de2da86d866fac28630194d41b1cc3e9f04efa6bc0b70c/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f2545372542342541322545352542432539352f62747265652e64726177696f2e706e67)\n \n> 通过主键查询商品数据的过程\n\n使用主键索引查询 id 号为 5 的商品。查询过程是这样的，B+Tree 会自顶向下逐层进行查找：\n\n- 将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree 的搜索逻辑，找到第二层的索引数据 (1，4，7)；\n- 在第二层的索引数据 (1，4，7) 中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；\n- 在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的行数据。\n\n数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。\n\nB+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以**B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4 次**。\n\n> 通过二级索引查询商品数据的过程\n\n主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：\n\n- 主键索引的 B+Tree 的叶子节点存放的是实际数据，**所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里**；\n- 二级索引的 B+Tree 的叶子节点存放的是**主键值**，而不是实际数据。\n\n![](https://camo.githubusercontent.com/89736228439b6b4975caa48682b0ad16956c8f168b3a03abee063f8f4739fd12/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f2545372542342541322545352542432539352f2545352539422539452545382541312541382e64726177696f2e706e67)\n\n如果使用二级索引查询数据，会先检查二级索引中的 B+Tree 的索引值，找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 查询到对应的叶子节点，然后获取整行数据。这个过程叫**回表**，也就是说要查两个 B+Tree 才能查到数据。\n\n不过，当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再去主键索引中查寻了。这种在二级索引的 B+Tree 就能查询到结果的过程就叫作**覆盖索引**，也就是只需要查一个 B+Tree 就能找到数据。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cuy4gmzpdrc0",
                                    "created": 1692610826150,
                                    "text": "Full-text 索引",
                                    "note": "TODO"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "cuy2j8i52n40",
                            "created": 1692605387485,
                            "text": "按物理存储分类",
                            "note": "聚簇索引（主键索引）、二级索引（辅助索引）。\n\n区别：\n\n- 主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；\n- 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。\n"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cuy4h9rbjog0",
                            "created": 1692610875709,
                            "text": "按字段特性分类",
                            "note": "主键索引、唯一索引、普通索引、前缀索引。\n\n- 主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。\n\n```\nCREATE TABLE table_name  (\n  ....\n  PRIMARY KEY (index_column_1) USING BTREE\n);\n```\n\n- 唯一索引建立在 `UNIQUE` 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。\n\n```SQL\nCREATE TABLE table_name  (\n  ....\n  UNIQUE KEY(index_column_1,index_column_2,...) \n);\n\nCREATE UNIQUE INDEX index_name\nON table_name(index_column_1,index_column_2,...); \n```\n\n- 普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。\n\n```SQL\nCREATE TABLE table_name  (\n  ....\n  INDEX(index_column_1,index_column_2,...) \n);\n\nCREATE INDEX index_name\nON table_name(index_column_1,index_column_2,...); \n```\n\n- 前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、varchar、binary、varbinary 的列上。\n使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。\n\n```SQL\nCREATE TABLE table_name(\n    column_list,\n    INDEX(column_name(length))\n); \n\nCREATE INDEX index_name\nON table_name(column_name(length)); \n```"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cuy4lbbycoo0",
                            "created": 1692611192590,
                            "text": "按字段个数分类",
                            "note": "单列索引、联合索引（复合索引）。\n\n联合索引的存储方式：\n![](https://camo.githubusercontent.com/e7d50a709b937710a34d73c9a2da6e8d4bfb76513844efca62e10590d022536b/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f2545372542342541322545352542432539352f2545382538312539342545352539302538382545372542342541322545352542432539352e64726177696f2e706e67)\n\n联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。\n\n因此，使用联合索引时，存在**最左匹配原则，也就是按照最左优先的方式进行索引的匹配**。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。\n\n因为联合索引中除了第一列是全局有序的之外，其它列是全局无序，局部相对有序的（第一列相等时才有序）。**利用索引的前提是索引里的 key 是有序的**。"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cuy4raxz0go0",
                                    "created": 1692611661929,
                                    "text": "联合索引范围查询",
                                    "note": "**并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询**。\n\n这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。也就是**范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引**。\n"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cuy4spthmg80",
                                            "created": 1692611772674,
                                            "text": "例1",
                                            "note": "`select * from t_table where a > 1 and b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？\n\n由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a > 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 a > 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a > 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。\n\n**但是在符合 a > 1 条件的二级索引记录的范围里，b 字段的值是无序的。**\n\n因此，我们不能根据查询条件 b = 2 来进一步减少需要扫描的记录数量（b 字段无法利用联合索引进行索引查询的意思）。\n\n所以在执行 Q1 这条查询语句的时候，对应的扫描区间是 (2, + ∞)，形成该扫描区间的边界条件是 a > 1，与 b = 2 无关。\n\n因此，Q1 这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引。\n\n"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cuy4wac6i7s0",
                                            "created": 1692612052433,
                                            "text": "例2",
                                            "note": "`select * from t_table where a >= 1 and b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？\n\n由例1可知，a 字段可以在联合索引的 B+Tree 中进行索引查询。\n\n虽然在符合 a>= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，**但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的**（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序）。\n\n于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 a 字段值为 1 时，可以通过 b = 2 条件减少需要扫描的二级索引记录范围（b 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 a = 1 and b = 2 条件的第一条记录开始扫描，而不需要从第一个 a 字段值为 1 的记录开始扫描。\n\n所以，这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cuy67i216lc0",
                                            "created": 1692615752349,
                                            "text": "例3",
                                            "note": "`SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？\n\n在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 **>= and =<**。而有的数据库则不包含 value1 和 value2 边界值（类似于 > and <）。\n\n因此这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cuy68io8qc00",
                                            "created": 1692615832056,
                                            "text": "例4",
                                            "note": "`SELECT * FROM t_user WHERE name like 'j%' and age = 22`，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？\n\n由于联合索引（二级索引）是先按照 name 字段的值排序的，所以前缀为‘j’的 name 字段的二级索引记录都是相邻的，于是在进行索引扫描的时候，可以定位到符合前缀为‘j’的 name 字段的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录的 name 前缀不为‘j’为止。\n\n所以 a 字段可以在联合索引的 B+Tree 中进行索引查询，形成的扫描区间是`['j','k')`。\n\n虽然在符合前缀为‘j’的 name 字段的二级索引记录的范围里，age 字段的值是「无序」的，**但是对于符合 name = j 的二级索引记录的范围里，age 字段的值是「有序」的**。\n\n于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 name 字段值为‘j’时，可以通过 age = 22 条件减少需要扫描的二级索引记录范围（age 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 `name = 'j' and age = 22` 条件的第一条记录时开始扫描，而不需要从第一个 name 为 j 的记录开始扫描。如下图的右边：\n![](https://camo.githubusercontent.com/a5de3f60111750afd2498ec12e0dc85aba8db25995decbba165505794221cf67/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f2545372542342541322545352542432539352f71342d322e64726177696f2e706e67)\n\n所以，这条查询语句两个字段都用到了联合索引进行索引查询。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cuy6dddb5uw0",
                                            "created": 1692616212332,
                                            "text": "总结",
                                            "note": "联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cuy6e9k4zkg0",
                                    "created": 1692616282402,
                                    "text": "索引下推",
                                    "note": "现在我们知道，对于联合索引（a, b），在执行 `select * from table where a > 1 and b = 2` 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？\n\n- 在 MySQL 5.6 之前，只能从 ID2（主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。\n\n- 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。\n\n当你的查询语句的执行计划里，出现了 Extra 为 `Using index condition`，那么说明使用了索引下推的优化。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cuy6gukf4q00",
                                    "created": 1692616484860,
                                    "text": "索引区分度",
                                    "note": "实际开发工作中建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。说人话就是把频率高的排在前面。\n\n![](https://camo.githubusercontent.com/160e064319de5b8c73ccf206c52ba36a8020b6b75a35dc85361baed2afbe498e/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f6d7973716c2f2545372542342541322545352542432539352f2545352538432542412545352538382538362545352542412541362e706e67)\n\n如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是\"30%\"）很高的时候，它一般会忽略索引，进行全表扫描。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cuy6j8yqqc00",
                                    "created": 1692616672929,
                                    "text": "联合索引进行排序",
                                    "note": "针对针对下面这条 SQL，怎么通过索引来提高查询效率：\n```sql\nselect * from order where status = 1 order by create_time asc;\n```\n\n给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。\n\n因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 `Using filesort`。\n\n所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率。"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "cuy3troyf600",
                            "created": 1692609034008,
                            "text": "B+Tree 相比于 B 树、二叉树或 Hash 索引结构的优势",
                            "note": "1. B+Tree vs B Tree\n\nB+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。\n\n另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。\n\n2. B+Tree vs 二叉树\n\n对于有 N 个叶子节点的 B+Tree，其搜索复杂度为`O(logdN)`，其中 d 表示节点允许的最大子节点个数为 d 个。\n\n在实际的应用当中，d 值是大于 100 的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3 ~ 4 层左右，也就是说一次数据查询操作只需要做 3 ~ 4 次的磁盘 I/O 操作就能查询到目标数据。\n\n而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 `O(logN)`，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。\n\n3. B+Tree vs Hash\n\nHash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。\n\n但是 Hash 表不适合做范围查询，它更适合做等值查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。",
                            "hyperlink": "https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html",
                            "hyperlinkTitle": "为什么MySQL选择 B+ 树"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cuy7d2kadc00",
                    "created": 1692619009919,
                    "text": "何时使用索引",
                    "note": "索引最大的好处是提高查询速度，但是索引也是有缺点的:\n\n- 占用物理空间，数据越大，占用的空间越大\n- 索引的创建和维护需要耗费时间，随着数据量增大而增大\n- 会降低表的 增删改效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护\n"
                },
                "children": [
                    {
                        "data": {
                            "id": "cuy7eybm5pk0",
                            "created": 1692619157416,
                            "text": "适用场景",
                            "note": "- 字段具有唯一性\n- 经常用 where 条件查询的字段，如果查询的不是一个字段，可以建立联合索引\n- 经常用 group by 和 order by 查询的字段，这样就不需要二次排序了"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cuy7gwuscuo0",
                            "created": 1692619310950,
                            "text": "不适用场景",
                            "note": "- where 条件、group by 和 order by 里用不到或很少用到的字段，不要为其创建索引\n- 存在大量重复数据的字段，不要为其创建索引\n- 表数据太少的时候\n- 经常更新的字段不要创建索引，因为索引字段频繁修改，由于要维护 B+Tree 的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cuy7izzt3z40",
                    "created": 1692619474512,
                    "text": "索引优化",
                    "note": "前缀索引就是使用某个字段中字符串的前几个字符建立索引。\n\n使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。\n\n不过，前缀索引有一定的局限性，例如：\n\n- order by 无法使用前缀索引\n- 无法应用于覆盖索引的场景"
                },
                "children": [
                    {
                        "data": {
                            "id": "cuy7jkjdiq80",
                            "created": 1692619519231,
                            "text": "前缀索引优化"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cuy7l3w23jc0",
                            "created": 1692619639721,
                            "text": "覆盖索引优化",
                            "note": "覆盖索引是指从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。\n\n使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cuy7mjjkeyw0",
                            "created": 1692619752158,
                            "text": "主键索引最好是自增的",
                            "note": "InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。\n\n- 如果使用自增主键\n\n那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动**开辟一个新页面**。因为**每次插入一条新记录，都是追加操作，不需要重新移动数据**，因此这种插入数据的方法效率非常高。\n\n- 如果使用非自增主键\n\n如果每次插入主键的索引值都是随机的，那么每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面**复制**数据到另外一个页面，我们通常将这种情况称为**页分裂**。页分裂还有可能会造成**大量的内存碎片，导致索引结构不紧凑，从而影响查询效率**。\n【如何避免】：可以自行实现主键递增算法，比如雪花算法。\n\n另外，主键字段的长度不要太大，因为**主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小**。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cuyvvw979ww0",
                            "created": 1692688191745,
                            "text": "分布式主键索引的选取",
                            "note": "TODO\n\n雪花算法"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cuy7pi6yhds0",
                            "created": 1692619984312,
                            "text": "索引最好设置为 NOT NULL",
                            "note": "有两个原因：\n\n1. 索引列存在NULL就会导致优化器在做索引选择的时候更加复杂，更加难以优化。因为可为 NULL 的列会使索引、索引统计和值比较更复杂，比如进行索引统计时，count 会省略值为 NULL 的行\n1. NULL 值没有意义，但是会占用物理空间"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cuy7rwactyg0",
                            "created": 1692620171720,
                            "text": "防止索引失效",
                            "hyperlink": "https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w",
                            "hyperlinkTitle": "索引失效",
                            "note": "发生索引失效的情况：\n\n- 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；\n- 当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；\n- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。\n- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。\n"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cuy7zwecjn40",
                            "created": 1692620798875,
                            "text": "执行计划",
                            "note": "一个没有使用索引，并且是一个全表扫描的查询语句：\n![](https://camo.githubusercontent.com/e8a84a96eeb24f8bf3717eadfd6b4c834837aa2926632a609f82a040d720791e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f37393861623133333164316436646666303236653236326537383866316132382e706e67)\n\n对于执行计划，各字段的意义：\n\n- possible_keys 字段表示可能用到的索引\n- key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引\n- key_len 表示索引的长度\n- rows 表示扫描的数据行数\n- type 表示数据扫描类型\n- extra\n\t- Using filesort：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候，这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。\n    - Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。\n    - Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。\n"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cuzx0lr3duo0",
                                    "created": 1692792941770,
                                    "text": "执行效率",
                                    "note": "type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的执行效率**从低到高**的顺序为：\n\n- All，全表扫描\n- index，全索引扫描\n- range，索引范围扫描\n- ref，非唯一索引扫描\n- eq_ref，唯一索引扫描\n- const，结果只有一条的主键或唯一索引扫描\n\nindex 和 all 差不多，只不过 index 对索引表进行全扫描，这样做的好处是不再需要对数据进行排序，但是开销依然很大。所以，要尽量避免全表扫描和全索引扫描。\n\nrange 表示采用了索引范围扫描，一般在 where 子句中使用 `< 、>、in、between` 等关键词，只检索给定范围的行，属于范围查找。**从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式**。\n\nref 类型表示采用了非唯一索引，或者是唯一索引的非唯一性前缀，返回数据返回可能是多条。因为虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。\n\neq_ref 类型是使用主键或唯一索引时产生的访问方式，通常使用在**多表联查中**。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。\n\nconst 类型表示使用了主键或者唯一索引与常量值进行比较，比如 `select name from product where id=1`。\n\n需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中。"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "template": "right",
    "theme": "classic",
    "version": "1.4.43"
}